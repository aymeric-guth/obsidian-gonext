/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  ExampleModal: () => ExampleModal,
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// constants.ts
var Paths = {
  Tasks: "813 Tasks",
  Components: "Components",
  Goals: "Goals",
  Slipbox: "803 Slipbox",
  Inbox: "800 Inbox",
  Refs: "802 Refs",
  Archives: "400 Archives",
  Logs: "600 Log",
  Attachments: "000 Attachments",
  Journal: "Journal",
  Resources: "Resources",
  Projects: "100 Projects",
  Domains: "Domains",
  Names: "Names"
};
var Status = {
  Todo: "todo",
  Doing: "doing",
  Done: "done",
  Maybe: "maybe",
  Standby: "standby",
  Trash: "trash"
};
var Types = {
  Fleeting: 13,
  Literature: 1,
  Permanent: 2,
  Task: 3,
  Praxis: 4,
  Provision: 5,
  Log: 6,
  Resource: 7,
  Media: 8,
  Project: 12,
  Org: 9,
  Domain: 10,
  Component: 11
};
var Namespace = {
  Area: "area",
  Context: "context",
  Layer: "layer",
  Org: "org",
  Project: "project"
};
var Default = {
  Area: "none",
  Context: "any",
  Layer: "none",
  Org: "none",
  Project: "none"
};

// api.ts
var FilterBy = class {
  constructor(fm) {
    this.fm = fm;
    if (fm === void 0) {
      this.predicates = [];
    } else {
      this.predicates = Array.isArray(fm.filter_by) ? fm.filter_by : [];
    }
  }
  nameInNamespace(fm, ns) {
    let found = false;
    if (ns.length === 0) {
      return true;
    }
    for (const a of ns) {
      const root = a.split("/");
      Assert.True(root.length === 2, `Invalid tag: '${a}'`);
      const parent = root[0].slice(0, 1) === "!" ? root[0].slice(1) : root[0];
      const name = Helper.getTag(fm, parent);
      if (a.slice(0, 1) === "!") {
        if (name === a.slice(1)) {
          return false;
        } else {
          found = true;
        }
      } else {
        if (name === a) {
          found = true;
        } else {
          found = false;
        }
      }
    }
    return found;
  }
  filter(fm) {
    if (this.predicates.length == 0) {
      return false;
    }
    return !this.nameInNamespace(fm, this.predicates);
  }
};
var FrontmatterJS = class {
  singular(values, field) {
    if (!Helper.nilCheck(this.fm[field])) {
      const value = this.fm[field];
      if (typeof value === "string") {
        if (!values.contains(value)) {
          values.push(value);
        }
      } else {
        console.warn(
          `'${field}' is ignored, invalid data-type: '${typeof this.fm[field]}'`
        );
      }
    }
  }
  plural(values, field) {
    if (!Helper.nilCheck(this.fm[field])) {
      if (!Array.isArray(this.fm[field])) {
        console.warn(
          `'${field}' is ignored, invalid data-type: '${field}'`
        );
      } else {
        for (const value of this.fm[field]) {
          if (typeof value === "string") {
            if (!values.contains(value)) {
              values.push(value);
            }
          } else {
            console.warn(
              `'${value}s.${value}' is ignored, invalid data-type: '${typeof value}'`
            );
          }
        }
      }
    }
  }
  constructor(page) {
    Assert.True(page !== void 0, "'page' is undefined");
    this.f = page.file;
    const f = this.f;
    Assert.True(f !== void 0, "'f' is undefined");
    this.fm = f.frontmatter;
    Assert.True(this.fm !== void 0, "'fm' is undefined");
    Assert.True(
      this.fm.uuid !== void 0,
      `'uuid' is undefined for '${this.f.path}'`
    );
    this.uuid = this.fm.uuid;
    this.version = this.fm.version;
    this.createdAt = new Date(this.fm.created_at);
    this.at = this.fm.at !== void 0 ? new Date(this.fm.at) : new Date();
    this.before = this.fm.before !== void 0 ? new Date(this.fm.before) : new Date();
    this.after = this.fm.after !== void 0 ? new Date(this.fm.after) : new Date();
    this.components = [];
    this.domains = [];
    this.projects = [];
    this.contexts = [];
    this.traits = [];
    const domains = [];
    const components = [];
    const projects = [];
    const names = [];
    const contexts = [];
    const contents = [];
    const traits = [];
    if (!Helper.nilCheck(this.fm.tags)) {
      if (!Array.isArray(this.fm.tags)) {
        console.warn("'tags' is ignored, invalid data-type");
        this.fm.tags = [];
      }
      for (const tag of this.fm.tags) {
        if (tag.slice(0, 7) === "domain/") {
          domains.push(tag.slice(7));
        } else if (tag.slice(0, 10) === "component/") {
          components.push(tag.slice(10));
        } else if (tag.slice(0, 8) === "project/") {
          projects.push(tag.slice(8));
        } else if (tag.slice(0, 5) === "name/") {
          names.push(tag.slice(5));
        } else if (tag.slice(0, 8) == "context/") {
          contexts.push(tag.slice(8));
        } else if (tag.slice(0, 8) == "content/") {
          contents.push(tag.slice(8));
        } else if (tag.slice(0, 6) == "trait/") {
          traits.push(tag.slice(6));
        }
      }
    }
    this.singular(domains, "domain");
    this.plural(domains, "domains");
    this.singular(components, "components");
    this.plural(components, "components");
    this.singular(projects, "project");
    this.plural(projects, "projects");
    this.singular(contents, "contents");
    this.plural(contents, "contents");
    this.singular(names, "name");
    this.plural(names, "names");
    this.plural(names, "alias");
    this.singular(traits, "trait");
    this.plural(traits, "traits");
    this.domains = domains;
    this.components = components;
    this.projects = projects;
    this.names = names;
    this.contexts = contexts;
    this.contents = contents;
    this.traits = traits;
  }
  getDomain(emptyDefault = true) {
    if (emptyDefault) {
      return this.domains[0];
    } else {
      return this.domains[0] === void 0 ? "unknown" : this.domains[0];
    }
  }
  getDomains() {
    return this.domains;
  }
  getTraits() {
    return this.traits;
  }
  getComponents() {
    return this.components;
  }
  getProject(emptyDefault = true) {
    if (emptyDefault) {
      return this.projects[0];
    } else {
      return this.projects[0] === void 0 ? "" : this.projects[0];
    }
  }
  getProjects() {
    return this.projects;
  }
  getName(emptyDefault = true) {
    if (emptyDefault) {
      return this.names[0];
    } else {
      return this.names[0] === void 0 ? "" : this.names[0];
    }
  }
  getContent(emptyDefault = true) {
    if (emptyDefault) {
      return this.contents[0];
    } else {
      return this.contents[0] === void 0 ? "" : this.contents[0];
    }
  }
  getNames() {
    return this.names;
  }
  getContext(emptyDefault = true) {
    if (emptyDefault) {
      return this.contexts[0];
    } else {
      return this.contexts[0] === void 0 ? "" : this.contexts[0];
    }
  }
  resolve(dv) {
    const domains = [];
    for (const domain of this.domains) {
      if (Helper.isUUID(domain)) {
        const pages = dv.pages(`"${Paths.Domains}"`).where((page) => page.file.frontmatter.uuid === domain);
        if (pages.length > 1) {
          throw new Error();
        } else if (pages.length === 1) {
          const page = pages[0];
          domains.push(page.file.frontmatter.name);
        }
      } else {
        const pages = dv.pages(`"${Paths.Domains}"`).where((page) => page.file.frontmatter.name === domain);
        if (pages.length > 1) {
          throw new Error();
        } else if (pages.length === 1) {
          const page = pages[0];
          domains.push(page.file.frontmatter.name);
        }
      }
    }
    if (domains.length !== this.domains.length) {
      console.warn(`Domain resolution failed for: ${this.domains}`);
    }
    this.domains = domains;
  }
};
var ValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
};
var Assert = {
  True(predicate, message) {
    if (!predicate) {
      throw new ValidationError(message);
    }
  }
};
var Helper = {
  nilCheck(val) {
    return val === void 0 || val === null;
  },
  getKeyFuck(groupBy) {
    switch (groupBy) {
      default:
      case "doneAt":
        return (entry) => entry.file.frontmatter.doneAt.toISOString().slice(0, 10);
        break;
      case "createdAt":
        return (entry) => entry.file.frontmatter.createdAt.toISOString().slice(0, 10);
        break;
      case "project":
        return (entry) => entry.file.frontmatter.project;
        break;
      case "area":
        return (entry) => entry.file.frontmatter.area;
        break;
    }
  },
  getKey(groupBy) {
    switch (groupBy) {
      default:
      case "doneAt":
        return (entry) => entry.doneAt.toISOString().slice(0, 10);
        break;
      case "createdAt":
        return (entry) => entry.createdAt.toISOString().slice(0, 10);
        break;
      case "project":
        return (entry) => entry.project;
        break;
      case "area":
        return (entry) => entry.area;
        break;
    }
  },
  numberTypeToString(val) {
    switch (val.type) {
      case Types.Fleeting:
        return "fleeting";
      case Types.Log:
        return "log";
      case Types.Project:
        return "project";
      case Types.Org:
        return "org";
      case Types.Domain:
        return "domain";
      case Types.Component:
        return "component";
      default:
        throw new Error(
          `numberTypeToString: type: "${val.type}" not implemented "${val.uuid}"`
        );
    }
  },
  roundToOneDecimal(val) {
    return Math.round(val * 10) / 10;
  },
  isChildTag(parent, child) {
    if (child.length <= parent.length + 1) {
      return false;
    } else if (child.slice(0, parent.length + 1) != `${parent}/`) {
      return false;
    }
    return true;
  },
  getField(field, defaultValue) {
    if (field === void 0 || field === null) {
      return defaultValue;
    } else {
      return field;
    }
  },
  getDate(dt) {
    if (dt === "" || dt === null) {
      return void 0;
    } else if (dt !== void 0) {
      dt = new Date(dt);
      if (isNaN(dt)) {
        return void 0;
      } else {
        return dt;
      }
    } else {
      return void 0;
    }
  },
  getTag(fm, type, emptyDefault = void 0) {
    let name = "";
    let defaultValue = "";
    if (type === "area") {
      name = Namespace.Area;
      defaultValue = Default.Area;
    } else if (type === "context") {
      name = Namespace.Context;
      defaultValue = Default.Context;
    } else if (type === "layer") {
      name = Namespace.Layer;
      defaultValue = Default.Layer;
    } else if (type === "org") {
      name = Namespace.Org;
      defaultValue = Default.Org;
    } else if (type === "project") {
      name = Namespace.Project;
      defaultValue = Default.Project;
    } else if (type == "domain") {
      name = "domain";
      defaultValue = "none";
    } else {
      throw new Error(`getTag got unsuported type: '${type}'`);
    }
    const len = name.length + 1;
    const defaultTag = `${name}/${defaultValue}`;
    let defaultRetVal = defaultTag;
    if (emptyDefault) {
      defaultRetVal = void 0;
    }
    if (fm === void 0) {
      return defaultRetVal;
    }
    const tags = fm.tags;
    if (tags === void 0 || tags.length === 0) {
      return defaultRetVal;
    }
    for (const tag of tags) {
      if (tag == defaultTag) {
        return defaultRetVal;
      }
      if (tag.length > len && tag.slice(0, len) == `${name}/`) {
        return tag;
      }
    }
    return defaultRetVal;
  },
  getName(fm) {
    const components = Helper.getComponents(fm);
    if (components.length < 1) {
      throw new Error(`Helper.getName() ${fm}`);
    }
    let name = void 0;
    let occurences = 0;
    for (const component of components) {
      if (component.slice(0, 15) === "component/name/") {
        name = component.slice(15);
        occurences += 1;
      }
    }
    if (occurences > 1) {
      throw new Error(
        `Helper.getName() ${fm} multiple occurences of 'component/name'`
      );
    }
    if (name === void 0) {
      throw new Error(
        `Helper.getName() ${fm} 'component/name' undefined`
      );
    }
    return name;
  },
  getComponents(fm) {
    const components = [];
    if (Helper.nilCheck(fm.tags)) {
      return [];
    }
    for (const tag of fm.tags) {
      if (tag.length > 10 && tag.slice(0, 10) === "component/") {
        components.push(tag);
      }
    }
    return components;
  },
  getArea(fm, emptyDefault = false) {
    return Helper.getTag(fm, "area", emptyDefault);
  },
  getContext(fm, emptyDefault = false) {
    return Helper.getTag(fm, "context", emptyDefault);
  },
  getDomain(fm, emptyDefault = false) {
    return Helper.getTag(fm, "domain", emptyDefault);
  },
  getLayer(fm, emptyDefault = false) {
    return Helper.getTag(fm, "layer", emptyDefault);
  },
  getOrg(fm, emptyDefault = false) {
    return Helper.getTag(fm, "org", emptyDefault);
  },
  getProject(fm, emptyDefault = false) {
    return Helper.getTag(fm, "project", emptyDefault);
  },
  durationStringToSec(val) {
    if (val === void 0 || val.length === 0) {
      return 0;
    }
    const mult = val.slice(-1);
    let m = 0;
    if (mult === "h") {
      m = 60 * 60;
    } else if (mult === "m") {
      m = 60;
    } else if (mult === "d") {
      m = 24 * 60 * 60;
    } else if (mult == "w") {
      m = 24 * 60 * 60 * 7;
    } else {
      console.warn(`Unhandled case val: ${val}`);
      return void 0;
    }
    return m * parseInt(val.slice(0, -1));
  },
  msecToStringDuration(val) {
    const oneHourInMsec = 36e5;
    const oneDayInMsec = 864e5;
    if (val >= 24 * oneHourInMsec) {
      return String(Helper.roundToOneDecimal(val / oneDayInMsec)).padStart(
        2,
        "0"
      ) + " d";
    } else {
      return String(Helper.roundToOneDecimal(val / oneHourInMsec)).padStart(
        2,
        "0"
      ) + " h";
    }
  },
  isUUID(val) {
    if (typeof val !== "string") {
      return false;
    }
    return val.length === 36;
  }
};
var AutoField = {
  tags(dv, fm, level = 2) {
    const tags = fm.tags;
    if (tags == void 0 || tags.length === 0) {
      return;
    }
    tags.sort();
    dv.header(level, "Tags");
    let s = "";
    for (const tag of tags) {
      s += ` #${tag}`;
    }
    dv.paragraph(s);
  },
  authors(dv, fm) {
    const authors = fm.authors;
    if (authors === void 0 || authors.length === 0) {
      return;
    }
    dv.header(3, "Authors");
    dv.list(authors);
  },
  title(dv, fm) {
    const title = fm.alias;
    if (title === void 0 || title.length === 0) {
      return;
    }
    dv.header(3, title);
  },
  logs(dv, entries) {
    const buff = [];
    let totalTime = 0;
    for (const entry of entries) {
      const fme = entry.file.frontmatter;
      const e = [];
      let start = 0;
      let stop = 0;
      if (fme === void 0 || fme.created_at === void 0) {
        throw new Error(`Invalid frontmatter: ${fme.uuid}`);
      }
      start = new Date(fme.created_at);
      e.push(start.toISOString().slice(0, 10));
      if (fme.done_at === void 0) {
        stop = Date.now();
      } else {
        stop = new Date(fme.done_at);
      }
      totalTime += stop - start;
      e.push(
        dv.sectionLink(
          fme.uuid,
          "## Content",
          false,
          fme.uuid.slice(0, 8)
        )
      );
      e.push(Math.round((stop - start) / (1e3 * 60 * 60) * 10) / 10);
      if (fme.reviewed === void 0 || fme.reviewed === 0) {
        e.push(0);
      } else {
        e.push(fme.reviewed);
      }
      buff.push(e);
    }
    if (buff.length > 0) {
      dv.header(2, "Logs");
      dv.table(["created_at", "uuid", "session", "reviewed"], buff);
      if (totalTime > 0) {
        dv.paragraph(
          `_totalTime (h):_ ${Math.round(totalTime / (1e3 * 60 * 60) * 10) / 10}`
        );
      }
    }
  },
  revisions(dv, entries) {
    const current = dv.current();
    const cols = ["", "created_at", "uuid"];
    const buff = [];
    for (const entry of entries) {
      const e = [];
      const fm = entry.file.frontmatter;
      if (current.file.frontmatter.uuid === fm.uuid) {
        e.push("->");
      } else {
        e.push("");
      }
      const start = new Date(fm.created_at);
      e.push(start.toISOString().slice(0, 10));
      e.push(
        dv.sectionLink(
          fm.uuid,
          "## Content",
          false,
          fm.uuid.slice(0, 8)
        )
      );
      buff.push(e);
    }
    if (buff.length > 1) {
      dv.header(2, "Revisions");
      dv.table(cols, buff);
    }
  },
  media(dv) {
    const current = dv.current();
    const fm = current.file.frontmatter;
    const pages = dv.pages(`"${Paths.Refs}/${fm.ref_id}"`).array();
    if (pages.length !== 1) {
      return;
    }
    const media = pages[0];
    const mediaFm = media.file.frontmatter;
    AutoField.title(dv, mediaFm);
    dv.paragraph(Renderer.makeLinkAlias(dv, media.file));
    AutoField.authors(dv, mediaFm);
    AutoField.tags(dv, mediaFm, 3);
    const logEntries = dv.pages(`"${Paths.Logs}/${fm.uuid}"`).where((p) => p.type === 6).sort((k) => k.created_at, "desc");
    AutoField.logs(dv, logEntries);
  },
  revisionsList(dv, root) {
    let head = dv.current();
    while (true) {
      const pages = dv.pages(`"${root}"`).where(
        (page) => page.file.frontmatter.next === head.file.frontmatter.uuid
      );
      if (pages.length > 1) {
        throw new Error();
      } else if (pages.length === 0) {
        break;
      }
      head = pages[0];
    }
    const buff = [];
    let cur = head;
    while (true) {
      buff.push(cur);
      const fm = cur.file.frontmatter;
      if (fm.next === void 0) {
        break;
      }
      const pages = dv.pages(`"${root}/${fm.next}"`);
      if (pages.length === 0) {
        break;
      }
      cur = pages[0];
    }
    return buff;
  },
  permanent(dv) {
    const fm = dv.current().file.frontmatter;
    const components = Helper.getComponents(fm);
    const traits = [];
    for (const component of components) {
      if (component.length > 16 && component.slice(0, 16) === "component/trait/") {
        traits.push(component.slice(16));
      }
    }
    if (traits.length === 0) {
      AutoField.tags(dv, fm, 2);
    } else {
      if (traits.length > 1) {
        throw new Error("Support for 1 trait only");
      }
      const trait = traits[0];
      if (trait !== "revision") {
        throw new Error(`Trait '${trait}' not implemented`);
      }
      const ontology = [];
      for (const component of components) {
        if (component.length > 16 && component.slice(0, 16) === "component/trait/") {
          continue;
        }
        ontology.push(`#${component}`);
      }
      ontology.push(`#${Helper.getDomain(fm)}`);
      const pages = dv.pages(ontology.join(" and ")).where((page) => page.file.frontmatter.type === fm.type).sort((k) => k.created_at, "desc").array();
      AutoField.revisions(dv, pages);
    }
  },
  autoFieldTitle(dv, fm) {
    const title = fm.alias;
    if (title == void 0) {
      return;
    }
    dv.header(1, title);
  },
  autoFieldAuthors(dv, fm) {
    const authors = fm.authors;
    if (authors === void 0 || authors.length === 0) {
      return;
    }
    dv.header(2, "Authors");
    dv.list(authors);
  },
  autoFieldTags(dv, fm) {
    const tags = fm.tags;
    if (tags == void 0 || tags.length === 0) {
      return;
    }
    tags.sort();
    dv.header(2, "Tags");
    let s = "";
    for (const tag of tags) {
      s += ` #${tag}`;
    }
    dv.paragraph(s);
  },
  literature(dv) {
    const current = dv.current();
    const fm = current.file.frontmatter;
    if (fm === void 0) {
      return;
    }
    if (Helper.nilCheck(fm.authors)) {
    } else {
      this.autoFieldTitle(dv, fm);
      this.autoFieldAuthors(dv, fm);
      this.autoFieldTags(dv, fm);
    }
  },
  domain(dv) {
    const current = dv.current();
    const fm = current.file.frontmatter;
    if (fm === void 0) {
      console.warn("fm is required");
      return;
    }
    Assert.True(fm.name !== void 0, "'name' is undefined");
    {
      const pages = dv.pages(`"${Paths.Goals}"`).where((p) => {
        const fml = new FrontmatterJS(p);
        if (fml.fm.status !== "todo") {
          return false;
        }
        if (fml.getDomain() !== fm.name) {
          return false;
        }
        return true;
      }).array();
      const rs = [];
      for (const page of pages) {
        const fme = page.file.frontmatter;
        if (fme === void 0 || fme.created_at === void 0 || fme.before === void 0) {
          throw new Error(`Invalid frontmatter: ${fme.uuid}`);
        }
        const entry = {
          uuid: fme.uuid,
          createdAt: new Date(fme.created_at),
          before: new Date(fme.before),
          delta: void 0
        };
        entry.delta = entry.before.getTime() - entry.createdAt.getTime();
        rs.push(entry);
      }
      rs.sort((a, b) => a.delta - b.delta);
      dv.header(2, "Goals");
      const buff = [];
      for (const entry of rs) {
        const e = [];
        e.push(
          dv.sectionLink(
            entry.uuid,
            "## Content",
            false,
            entry.uuid.slice(0, 8)
          )
        );
        e.push(entry.before.toISOString().slice(0, 10));
        buff.push(e);
      }
      dv.table(["uuid", "before"], buff);
    }
    {
      const fmd = new FrontmatterJS({ file: { frontmatter: fm } });
      fmd.resolve(dv);
      const buff = [];
      for (const domain of fmd.getDomains()) {
        buff.push([`#domain/${domain}`]);
      }
      dv.header(2, "Domains");
      dv.table(["name"], buff);
    }
  },
  resource(dv) {
    return AutoField.permanent(dv);
  },
  generic(dv) {
    const current = dv.current();
    const fm = new FrontmatterJS(current);
    const path = fm.f.path;
    const dirname = path.split("/")[0];
    if (dirname === void 0) {
      throw new Error("unexpected error");
    }
    if (dirname === Paths.Tasks) {
    } else if (dirname == Paths.Inbox) {
    } else {
      return;
      throw new Error("not implemented");
    }
    const links = [];
    for (const trait of fm.getTraits()) {
      if (trait.slice(0, 4) === "link") {
        links.push(trait.slice(5));
      }
    }
    const refs = [];
    for (const link of links) {
      const pages = dv.pages().where((page) => page.file.frontmatter.uuid === link);
      if (pages.length === 1) {
        refs.push(pages[0]);
      } else {
        console.warn(`referencing unkown resource: '${link}'`);
      }
    }
    if (refs.length > 0) {
      dv.header(2, "refs");
      for (const ref of refs) {
        dv.paragraph(Renderer.makeLinkAlias(dv, ref.file));
      }
    }
  },
  calendar(dv) {
    const current = dv.current().file.frontmatter;
    const currentAt = new Date(current.at);
    const currentAtShort = currentAt.toISOString().slice(0, 10);
    const pages = dv.pages(`"Calendar"`).where((page) => {
      const fm = page.file.frontmatter;
      if (fm.completed === true) {
        return false;
      }
      const now = new Date();
      if (fm.date !== currentAtShort) {
        return false;
      }
      if (fm.completed === false) {
        return true;
      } else {
        return true;
      }
    }).sort((k) => k.at, "asc");
    if (pages.length === 0) {
      return;
    }
    const buff = [];
    for (const page of pages) {
      const fm = page.file.frontmatter;
      buff.push([`${fm.startTime} - ${fm.endTime}`, `${fm.title}`]);
    }
    console.log(pages.length);
    dv.table(["at", "title"], buff);
  },
  daily(dv) {
    const current = dv.current().file.frontmatter;
    const currentAt = new Date(current.at);
    const currentAtShort = currentAt.toISOString().slice(0, 10);
    const pages = dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = new FrontmatterJS(page);
      if (current.uuid === fm.uuid) {
        return false;
      }
      if (fm.fm.status !== "todo" || fm.getProject() === "daily") {
        return false;
      }
      const now = new Date();
      if (page.file.frontmatter.at !== void 0 && fm.at.toISOString().slice(0, 10) === currentAtShort) {
        return true;
      }
      if (page.file.frontmatter.at !== void 0 && fm.at.getTime() < now.getTime()) {
        return true;
      }
      if (page.file.frontmatter.before !== void 0 && fm.before.getTime() > now.getTime()) {
        return true;
      }
      if (page.file.frontmatter.after !== void 0 && fm.after.getTime() < now.getTime()) {
        return true;
      }
      return false;
    }).sort((k) => k.at, "asc");
    if (pages.length === 0) {
      return;
    }
    const buff = [];
    for (const page of pages) {
      const fm = new FrontmatterJS(page);
      const h = String(fm.at.getHours()).padStart(2, "0");
      const m = String(fm.at.getMinutes()).padStart(2, "0");
      if (page.file.frontmatter.status === "done") {
        buff.push([
          `~~${Renderer.makeLinkShortUUID(dv, page.file, "Task")}~~`,
          `~~${h}:${m}~~`
        ]);
      } else {
        buff.push([
          `${Renderer.makeLinkShortUUID(dv, page.file, "Task")}`,
          `${h}:${m}`
        ]);
      }
    }
    dv.table(["uuid", "at"], buff);
  }
};
var Renderer = {
  makeLinkName(dv, f, anchor = "Content") {
    if (Helper.nilCheck(f.frontmatter.name)) {
      return Renderer.makeLinkShortUUID(dv, f, anchor);
    }
    return dv.sectionLink(f.path, anchor, false, `${f.frontmatter.name}`);
  },
  makeLinkAlias(dv, f, anchor = "Content") {
    if (Helper.nilCheck(f.frontmatter.alias)) {
      return Renderer.makeLinkShortUUID(dv, f, anchor);
    }
    return dv.sectionLink(f.path, anchor, false, `${f.frontmatter.alias}`);
  },
  makeLinkShortUUID(dv, f, anchor = "Content") {
    return dv.sectionLink(
      f.path,
      anchor,
      false,
      `${f.frontmatter.uuid.slice(0, 8)}`
    );
  },
  makeLink(dv, f, name = void 0, anchor = "Content") {
    return dv.sectionLink(f.path, anchor, false, name);
  },
  projectLogs(dv, data) {
    const cols = ["type", "task_id", "log_id", "took", "reviewed"];
    const buff = [];
    let totalTime = 0;
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.uuid),
        `"uuid" id not defined for: ${f.path}`
      );
      Assert.True(
        !Helper.nilCheck(fm.type),
        `"type" id not defined for: ${f.path}`
      );
      const createdAt = new Date(fm.created_at);
      const doneAt = new Date(fm.done_at);
      const delta = doneAt.getTime() - createdAt.getTime();
      totalTime += delta;
      const record = {
        taskId: "",
        logId: Renderer.makeLinkAlias(dv, f),
        took: Math.round(delta / (1e3 * 60 * 60) * 10) / 10,
        reviewed: Helper.nilCheck(fm.reviewed) ? 0 : fm.reviewed,
        type: void 0
      };
      const pages = dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
      if (pages.length !== 1) {
        throw new Error(
          `parent task with id: "${fm.parent_id}" does not exists`
        );
      }
      const parent = pages[0];
      switch (parent.file.frontmatter.type) {
        case Types.Task:
          record.type = `<font color=8B0000>task</font>`;
          record.taskId = Renderer.makeLinkShortUUID(
            dv,
            parent.file,
            "Task"
          );
          break;
        case Types.Media:
          record.type = `<font color=00008B>media</font>`;
          record.taskId = Renderer.makeLinkShortUUID(
            dv,
            parent.file,
            "Content"
          );
          break;
        case Types.Praxis:
          record.type = `<font color=FF8C00>praxis</font>`;
          record.taskId = Renderer.makeLinkShortUUID(
            dv,
            parent.file,
            "Content"
          );
          break;
        case Types.Provision:
          record.type = `<font color=DC143C>provision</font>`;
          record.taskId = Renderer.makeLinkShortUUID(
            dv,
            parent.file,
            "Content"
          );
          break;
        default:
          throw new Error(
            `Renderer.projectLogs: type "${parent.file.frontmatter.type}" not implemented`
          );
      }
      buff.push([
        record.type,
        record.taskId,
        record.logId,
        record.took,
        record.reviewed
      ]);
    }
    dv.table(cols, buff);
  },
  goal(dv, data) {
    const buff = [];
    for (const fm of data) {
      const created_at = fm.createdAt;
      const logEntries = dv.pages(`"${Paths.Logs}/${fm.uuid}"`).where((p) => p.type === 6).sort((k) => k.created_at, "desc");
      const before = new Date(fm.fm.before);
      const timeframe = (before.getTime() - created_at.getTime()) / (1e3 * 3600 * 24);
      let timeframeText = "";
      if (timeframe > 0 && timeframe < 30) {
        timeframeText = "runaway";
      } else if (timeframe < 60) {
        timeframeText = "10,000 feet";
      } else if (timeframe < 360) {
        timeframeText = "20,000 feet";
      } else if (timeframe < 720) {
        timeframeText = "30,000 feet";
      } else if (timeframe < 1080) {
        timeframeText = "40,000 feet";
      } else {
        timeframeText = "50,000 feet";
      }
      buff.push([
        before.toISOString().slice(0, 10),
        dv.sectionLink(
          fm.uuid,
          "## Content",
          false,
          fm.uuid.slice(0, 8)
        ),
        fm.getDomain(),
        timeframeText
      ]);
    }
    dv.table(["deadline", "uuid", "domain", "timeframe"], buff);
  },
  inboxEntry(dv, data) {
    const cols = [
      "uuid",
      // "type",
      // "age",
      // "size",
      "name"
      // "project",
      // "domain",
      // "components",
    ];
    const buff = [];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.uuid),
        `"uuid" id not defined for: ${f.path}`
      );
      Assert.True(
        !Helper.nilCheck(fm.type),
        `"type" id not defined for: ${f.path}`
      );
      const now = new Date();
      const delta = now.getTime() - fm.createdAt.getTime();
      const since = Helper.msecToStringDuration(delta);
      let name = "";
      console.log("\n");
      console.log(fm.domain);
      console.log(fm.project);
      console.log("\n");
      if (fm.domain !== "domain/undefined") {
        name = fm.domain;
      } else if (fm.project !== void 0) {
        name = fm.project;
      } else {
        name = "\\-";
      }
      const record = {
        uuid: Helper.numberTypeToString(fm) === "fleeting" ? `&#128196 ${Renderer.makeLinkAlias(dv, f)}` : Renderer.makeLinkAlias(dv, f),
        // uuid: `&#9728 ${Renderer.makeLinkAlias(dv, f)}`,
        type: Helper.numberTypeToString(fm),
        since: `${since}`,
        size: f.size,
        project: fm.project === void 0 ? "\\-" : fm.project.slice(8),
        domain: fm.domain === void 0 ? "\\-" : fm.domain.slice(7),
        //Renderer.domainBase(dv, fm.domain),
        name
      };
      if (record.type === "log") {
        const pages = dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
        if (pages.length !== 1) {
          throw new Error(`${fm.parent_id} ${fm.id}`);
        }
        const parent = pages[0];
        switch (parent.type) {
          case Types.Task:
            record.uuid = `&#128211 ${record.uuid}`;
            record.type = `<font color=8B0000>task</font>`;
            break;
          case Types.Praxis:
            record.uuid = `&#128188 ${record.uuid}`;
            record.type = `<font color=FF8C00>praxis</font>`;
            break;
          case Types.Media:
            record.uuid = `&#128191 ${record.uuid}`;
            record.type = `<font color=00008B>media</font>`;
            break;
          case Types.Provision:
            record.type = `<font color=DC143C>provision</font>`;
            break;
          default:
            break;
        }
      }
      buff.push([
        record.uuid,
        // record.type,
        // record.since,
        // record.size,
        record.name
        // record.project,
        // record.domain,
      ]);
    }
    dv.table(cols, buff);
  },
  adhocTaskReady(dv, data) {
    const buff = [];
    const cols = ["uuid", "task", "estimate"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      switch (fm.type) {
        case Types.Task:
          buff.push([
            Renderer.makeLinkAlias(dv, f, "Task"),
            dv.markdownTaskList(f.tasks),
            fm.time_estimate,
            Helper.getField(Helper.getDomain(fm, true), "\\-")
          ]);
          break;
        case Types.Praxis:
          buff.push([
            Renderer.makeLinkAlias(dv, f, "Task"),
            dv.markdownTaskList(f.tasks),
            fm.time_estimate,
            Helper.getField(Helper.getDomain(fm, true), "\\-")
          ]);
          break;
        case Types.Media:
          const pages = dv.pages(`"${Paths.Refs}/${fm.ref_id}"`).array();
          if (pages.length !== 1) {
            throw new Error(
              `adhocTaskReady: ref_id: "${fm.ref_id}" not found`
            );
          }
          buff.push([
            Renderer.makeLinkAlias(dv, f, "Content"),
            Renderer.makeLinkAlias(dv, pages[0].file, "Content"),
            fm.time_estimate,
            Helper.getField(Helper.getDomain(fm, true), "\\-")
          ]);
          break;
        default:
          throw new Error(
            `adhocTaskReady: Unhandled type: '${fm.type}'`
          );
      }
    }
    dv.table(cols, buff);
  },
  domainBase(dv, data) {
    if (data === Helper.getDomain({})) {
      return "\\-";
    } else {
      return `#${data}`;
    }
  },
  componentsBase(dv, data) {
    if (data.length === 0) {
      return "\\-";
    } else {
      const buff = [];
      for (const d of data) {
        buff.push(`#${d}`);
      }
      return buff.join("<br>");
    }
  },
  ontologyBase(dv, fm) {
    const buff = [`#${Helper.getDomain(fm)}`];
    const components = Helper.getComponents(fm);
    components.sort();
    for (const component of components) {
      buff.push(`#${component}`);
    }
    return buff.join("<br>");
  },
  knowledgeFull(dv, data) {
    const cols = ["uuid", "ontology"];
    const buff = [];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      buff.push([
        Renderer.makeLinkAlias(dv, f),
        Renderer.ontologyBase(dv, fm)
      ]);
    }
    dv.table(cols, buff);
  },
  knowledgeBase(dv, data) {
    for (const d of data) {
      dv.paragraph(Renderer.makeLinkAlias(dv, d.file));
    }
  },
  resourceBase(dv, data) {
    const cols = ["uuid"];
    const buff = [];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.uuid),
        `"uuid" id not defined for: ${f.path}`
      );
      buff.push([Renderer.makeLinkAlias(dv, f)]);
    }
    dv.table(cols, buff);
  },
  // ne pas réutiliser pour le moment
  basicDomain(dv, data) {
    const cols = ["uuid", "name", "parents"];
    const buff = [];
    for (const d of data) {
      const parents = d.getDomains();
      Assert.True(
        !Helper.nilCheck(d.uuid),
        `"uuid" id not defined for: ${d.f.path}`
      );
      const values = [];
      for (const parent of parents) {
        const page = dv.pages(`"${Paths.Domains}"`).where((page2) => page2.file.frontmatter.name === parent);
        if (page.length !== 1) {
          console.warn(
            `Unknown domain '${parent}' delcared by: ${d.file.frontmatter.uuid}`
          );
          continue;
        }
        values.push(
          dv.sectionLink(
            `${Paths.Domains}/${page[0].file.frontmatter.uuid}`,
            "Content",
            false,
            `${parent}`
          )
        );
      }
      const entry = [
        Renderer.makeLinkAlias(dv, d.f),
        d.getName(),
        values.length === 0 ? "" : values
      ];
      buff.push(entry);
    }
    dv.table(cols, buff);
  },
  basicRelation(dv, data) {
    const cols = ["uuid", "name"];
    const buff = [];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.uuid),
        `"uuid" id not defined for: ${f.path}`
      );
      buff.push([Renderer.makeLinkAlias(dv, f), fm.name]);
    }
    dv.table(cols, buff);
  },
  basicFleeting(dv, data) {
    const cols = ["content", "age", "size"];
    const buff = [];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.uuid),
        `"uuid" id not defined for: ${f.path}`
      );
      const dt = app.plugins.plugins.gonext.api.frontmatter.getCreatedAt(f);
      const now = new Date();
      const delta = now.getTime() - dt.getTime();
      const since = Helper.msecToStringDuration(delta);
      buff.push([Renderer.makeLinkAlias(dv, f), `${since}`, f.size]);
    }
    dv.table(cols, buff);
  },
  basicLog(dv, entry) {
    const cols = ["uuid", "created_at", "project", "area"];
    const logs = dv.pages(`"${Paths.Logs}"`).where(
      (p) => p.type === Types.Log && (p.reviewed === void 0 || p.reviewed < 1)
    ).sort((k) => k.created_at, "asc");
    const buff = [];
    for (const entry2 of logs) {
      const fm = entry2.file.frontmatter;
      const parentId = fm.parent_id;
      if (parentId === void 0) {
        throw new Error(`Invalid log entry: ${entry2.file.path}`);
      }
      const parent = dv.pages(`"${Paths.Tasks}/${parentId}"`);
      const parentFm = parent.file.frontmatter;
      const project = Helper.getField(
        Helper.getProject(parentFm, true),
        ""
      );
      const area = Helper.getField(Helper.getArea(parentFm, true), "");
      const createdAt = new Date(fm.created_at);
      buff.push([
        dv.sectionLink(
          entry2.file.path,
          "Content",
          false,
          `${fm.uuid.slice(0, 8)}`
        ),
        createdAt.toISOString().slice(0, 10),
        project,
        area
      ]);
    }
    dv.table(cols, buff);
  },
  mediaBase(dv, data) {
    const buff = [];
    const cols = ["uuid", "tasks", "estimate", "area"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      const area = Helper.getArea(fm);
      buff.push([
        dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
        dv.markdownTaskList(f.tasks),
        fm.time_estimate,
        area
      ]);
    }
    dv.table(cols, buff);
  },
  praxisBase(dv, data) {
    const buff = [];
    const cols = ["tasks", "uuid", "estimate"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      buff.push([
        dv.markdownTaskList(f.tasks),
        dv.fileLink(f.path, false, f.name.slice(0, 8)),
        fm.time_estimate
      ]);
    }
    dv.table(cols, buff);
  },
  waitingTask(dv, data) {
    const buff = [];
    const cols = ["tasks", "uuid", "estimate", "cause"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      buff.push([
        dv.markdownTaskList(f.tasks),
        dv.fileLink(f.path, false, f.name.slice(0, 8)),
        fm.time_estimate,
        fm.cause
      ]);
    }
    dv.table(cols, buff);
  },
  readyTask(dv, data) {
    const buff = [];
    const cols = ["uuid", "task", "estimate", "area"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      buff.push([
        Renderer.makeLinkAlias(dv, f, "Task"),
        dv.markdownTaskList(f.tasks),
        fm.time_estimate,
        Helper.getField(Helper.getArea(fm, true), "\\-")
      ]);
    }
    dv.table(cols, buff);
  },
  provisionBase(dv, data) {
    const buff = [];
    const cols = ["uuid", "supplier", "content", "estimate"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      buff.push([
        dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
        fm.supplier,
        dv.markdownTaskList(f.tasks),
        fm.time_estimate
      ]);
    }
    dv.table(cols, buff);
  },
  basicTaskJournal(dv, data) {
    const buff = [];
    const cols = ["uuid", "tasks", "estimate"];
    for (const d of data) {
      console.log(d);
      const f = d.file;
      const fm = f.frontmatter;
      const domain = Helper.getDomain(fm, true) === void 0 ? "\\-" : Helper.getDomain(fm);
      if (fm.ref_id === void 0) {
        buff.push([
          // journal.contains(fm.uuid) ? "->" : "\\-",
          dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
          dv.markdownTaskList(f.tasks),
          fm.time_estimate
        ]);
      } else {
        const ref = dv.pages(`"${Paths.Refs}/${fm.ref_id}"`).array();
        if (ref.length === 0) {
          throw new Error(
            `task: '${fm.uuid}' has an undefined ref_id: '${fm.ref_id}'`
          );
        } else {
          buff.push([
            dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
            Renderer.makeLinkAlias(dv, ref[0].file),
            fm.time_estimate,
            domain
          ]);
        }
      }
    }
    dv.table(cols, buff);
  },
  activeTask(dv, data) {
    const buff = [];
    const cols = ["uuid", "tasks", "session"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      const logs = dv.pages(`"${Paths.Logs}/${fm.uuid}"`).where((p) => p.type === 6).sort((k) => k.created_at, "desc");
      const last = logs[0];
      const createdAt = new Date(last.created_at);
      const now = new Date();
      buff.push([
        dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
        dv.markdownTaskList(f.tasks),
        ((t) => {
          return Math.round(t / (3600 * 1e3) * 10) / 10;
        })(now.getTime() - createdAt.getTime())
      ]);
    }
    dv.table(cols, buff);
  },
  basicTask(dv, data) {
    const buff = [];
    const cols = ["uuid", "tasks", "estimate", "domain"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      const domain = Helper.getDomain(fm, true) === void 0 ? "\\-" : Helper.getDomain(fm);
      if (fm.ref_id === void 0) {
        buff.push([
          dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
          dv.markdownTaskList(f.tasks),
          fm.time_estimate,
          domain
        ]);
      } else {
        const ref = dv.pages(`"${Paths.Refs}/${fm.ref_id}"`).array();
        if (ref.length === 0) {
          throw new Error(
            `task: '${fm.uuid}' has an undefined ref_id: '${fm.ref_id}'`
          );
        } else {
          buff.push([
            dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
            Renderer.makeLinkAlias(dv, ref[0].file),
            fm.time_estimate,
            domain
          ]);
        }
      }
    }
    dv.table(cols, buff);
  },
  logs(dv, entries) {
    const buff = [];
    let totalTime = 0;
    for (const entry of entries) {
      const fme = entry.file.frontmatter;
      const e = [];
      let start = 0;
      let stop = 0;
      if (fme === void 0 || fme.created_at === void 0) {
        throw new Error(`Invalid frontmatter: ${fme.uuid}`);
      }
      start = new Date(fme.created_at);
      e.push(start.toISOString().slice(0, 10));
      if (fme.done_at === void 0) {
        stop = Date.now();
      } else {
        stop = new Date(fme.done_at);
      }
      totalTime += stop - start;
      e.push(
        dv.sectionLink(
          fme.uuid,
          "## Content",
          false,
          fme.uuid.slice(0, 8)
        )
      );
      e.push(Math.round((stop - start) / (1e3 * 60 * 60) * 10) / 10);
      if (fme.reviewed === void 0 || fme.reviewed === 0) {
        e.push(0);
      } else {
        e.push(fme.reviewed);
      }
      buff.push(e);
    }
    if (buff.length > 0) {
      dv.header(2, "Logs");
      dv.table(["created_at", "uuid", "session", "reviewed"], buff);
      if (totalTime > 0) {
        dv.paragraph(
          `_totalTime (h):_ ${Math.round(totalTime / (1e3 * 60 * 60) * 10) / 10}`
        );
      }
    }
  },
  mediaWithLogs(dv, data) {
    const buff = [];
    const cols = ["uuid", "tasks", "estimate", "current", "domain"];
    for (const d of data) {
      const f = d.file;
      const fm = f.frontmatter;
      const ref = dv.pages(`"${Paths.Refs}/${fm.ref_id}"`).array();
      if (ref.length === 0) {
        throw new Error(
          `task: '${fm.uuid}' has an undefined ref_id: '${fm.ref_id}'`
        );
      }
      const domain = Helper.getDomain(fm, true) === void 0 ? "\\-" : Helper.getDomain(fm);
      const logEntries = dv.pages(`"${Paths.Logs}/${fm.uuid}"`).where((p) => p.type === Types.Log).sort((k) => k.created_at, "desc");
      let totalTime = 0;
      for (const entry of logEntries) {
        const fme = entry.file.frontmatter;
        const e = [];
        let start = 0;
        let stop = 0;
        if (fme === void 0 || fme.created_at === void 0) {
          throw new Error(`Invalid frontmatter: ${fme.uuid}`);
        }
        start = new Date(fme.created_at);
        e.push(start.toISOString().slice(0, 10));
        if (fme.done_at === void 0) {
          stop = Date.now();
        } else {
          stop = new Date(fme.done_at);
        }
        totalTime += stop - start;
      }
      buff.push([
        dv.fileLink(f.path, false, fm.uuid.slice(0, 8)),
        Renderer.makeLinkAlias(dv, ref[0].file),
        fm.time_estimate,
        `${Math.round(totalTime / (1e3 * 60 * 60) * 10) / 10}h`,
        domain
      ]);
    }
    dv.table(cols, buff);
  },
  taskDoneWithLogs(dv, data) {
    const buff = [];
    const cols = [
      "taskId",
      "logId",
      "createdAt",
      "doneAt",
      "timeEstimate",
      "took",
      "project"
    ];
    for (const d of data) {
      const f = d.file;
      const fm = d.file.frontmatter;
      const createdAt = new Date(fm.created_at);
      const doneAt = new Date(fm.done_at);
      const timeEstimate = "";
      const took = (doneAt - createdAt) / (1e3 * 3600);
      const pages = dv.pages(`"${Paths.Tasks}"`).where((page) => page.file.frontmatter.uuid === fm.parent_id);
      if (pages.length !== 1) {
        throw new Error();
      }
      const parent = pages[0];
      const parentFm = parent.file.frontmatter;
      const parentF = parent.file;
      buff.push([
        Renderer.makeLinkShortUUID(dv, parent.file, "Task"),
        Renderer.makeLinkShortUUID(dv, f),
        createdAt.toISOString().slice(0, 10),
        doneAt.toISOString().slice(0, 10),
        timeEstimate,
        ((t) => {
          return Math.round(t * 10) / 10;
        })(took),
        Helper.getProject(parentFm)
      ]);
    }
    dv.table(cols, buff);
  },
  basicDoneTaskWithLogs(dv, data) {
    const cols = [
      "uuid",
      "createdAt",
      "doneAt",
      "timeEstimate",
      "took",
      "delta",
      "project",
      "area"
    ];
    dv.table(cols, data);
  },
  basicDoneTaskWithoutLogs(dv, data) {
    const cols = ["taskId", "createdAt", "project", "area"];
    dv.table(cols, data);
  },
  basicProgressedTaskWithLog(dv, data) {
    const cols = [
      "taskId",
      "logId",
      // "createdAt",
      // "doneAt",
      "took",
      // "tookAcc",
      "project"
      // "domain",
    ];
    dv.table(cols, data);
  },
  // dailyTask(dv, data) {
  // 	Renderer.makeLinkShortUUID(this.dv, page.file),
  // 	dv.
  // 				rs.push([
  // 					"paragraph",
  // 					Renderer.makeLinkShortUUID(this.dv, page.file),
  // 				]);
  // }
  do(dv, rs) {
    for (const row of rs) {
      switch (row[0]) {
        case "header":
          const [, level, heading] = row;
          dv.header(level, heading);
          break;
        case "paragraph":
          const [, text] = row;
          dv.paragraph(text);
          break;
        case "array":
          const [, renderer, data] = row;
          renderer(dv, data);
          break;
        case "stats":
          const [, name, unit, value] = row;
          dv.paragraph(`${name} (${unit}): ${value}`);
          break;
        default:
          throw new Error(`Unsuported opcode: "fuckoff"`);
      }
    }
  }
};
var Frontmatter = class {
  constructor(gonext) {
    this.gonext = gonext;
  }
  projectParseMeta(dv) {
    const current = dv.current();
    const projectName = current.file.folder.slice(
      Paths.Projects.length + 1
    );
    const projectDir = current.file.folder;
    if (projectName.contains("/")) {
      throw new Error(
        `projectDir: ${projectDir} folder: ${current.file.folder}`
      );
    }
    const pages = dv.pages(`"${projectDir}/meta"`).array();
    if (pages.length !== 1) {
      throw new Error(`len: ${pages.length}`);
    }
    const fm = pages[0].file.frontmatter;
    const uuid = fm.uuid;
    if (Helper.nilCheck(uuid)) {
      throw new Error(`project 'uuid' is not defined`);
    }
    const name = fm.name;
    if (Helper.nilCheck(name)) {
      throw new Error(`'name' is not defined`);
    }
    const domains = fm.domains;
    if (!Array.isArray(domains)) {
      throw new Error(`'domains' must be of array type`);
    }
    return {
      uuid,
      name,
      domains
    };
  }
  getCreatedAt(f) {
    return Helper.nilCheck(f.frontmatter.created_at) ? new Date(f.ctime.ts) : new Date(f.frontmatter.created_at);
  }
  getCurrentFrontmatter() {
    const file = this.gonext.workspace.getActiveFile();
    const fileContent = this.gonext.metadataCache.getFileCache(file);
    if (fileContent === void 0) {
      return void 0;
    }
    const fm = fileContent.frontmatter;
    if (fm === void 0) {
      return void 0;
    }
    return fm;
  }
  parseListByNamespace(fm) {
    const byAreas = fm.by_areas === void 0 ? [] : fm.by_areas;
    const byContexts = fm.by_contexts === void 0 ? [] : fm.by_contexts;
    const byLayers = fm.by_layers === void 0 ? [] : fm.by_layers;
    const byOrgs = fm.by_orgs === void 0 ? [] : fm.by_orgs;
    const byProjects = fm.by_projects === void 0 ? [] : fm.by_projects;
    return [byAreas, byContexts, byLayers, byOrgs, byProjects];
  }
  parseListBeforeAfter(fm) {
    const before = Helper.getDate(fm.before);
    const after = Helper.getDate(fm.after);
    return [before, after];
  }
  parseListFilterBy(fm) {
    if (fm === void 0) {
      return [];
    }
    const filterBy = fm.filter_by;
    if (!Array.isArray(filterBy)) {
      return [];
    }
    return filterBy;
  }
  parseListGroupBy(fm) {
    if (fm === void 0) {
      return "";
    }
    const groupBy = fm.group_by;
    if (!(typeof groupBy === "undefined") && !(typeof groupBy === "string")) {
      return "";
    }
    return groupBy;
  }
  parseAllProgressedTasks() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      throw new Error(`Invalid frontmatter, cannot proceed`);
    }
    const groupBy = this.parseListGroupBy(fm);
    const filterBy = this.parseListFilterBy(fm);
    const [before, after] = this.parseListBeforeAfter(fm);
    return [groupBy, filterBy, before, after];
  }
  parseAllDoneTasks() {
    return this.parseAllProgressedTasks();
  }
  parseAllDoneTaskWithoutLog() {
    return this.parseAllProgressedTasks();
  }
  parseAllTodoAdHoc() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      throw new Error(`Invalid frontmatter, cannot proceed`);
    }
    const groupBy = this.parseListGroupBy(fm);
    const filterBy = this.parseListFilterBy(fm);
    const [before, after] = this.parseListBeforeAfter(fm);
    const minPriority = Helper.getField(fm.min_priority, 0);
    return [groupBy, filterBy, before, after, minPriority];
  }
  parseInbox() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      return [[], [], 0, 4294967295];
    }
    const source = Helper.nilCheck(fm.source) ? ["logs", "fleeting"] : fm.source;
    const groupBy = Helper.nilCheck(fm.group_by) ? "none" : fm.group_by;
    const filterBy = this.parseListFilterBy(fm);
    const minSize = Helper.nilCheck(fm.min_size) ? 0 : fm.min_size;
    const maxSize = Helper.nilCheck(fm.max_size) ? 4294967295 : fm.max_size;
    return [source, groupBy, filterBy, minSize, maxSize];
  }
  parseJournal() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      return [[], [], [], [], []];
    }
    const [byAreas, byContexts, byLayers, byOrgs, byProjects] = this.parseListByNamespace(fm);
    const tasks = Helper.getField(fm.tasks, []);
    return [byAreas, byContexts, byLayers, byOrgs, byProjects, tasks];
  }
  parseTodoList() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      return [[], [], [], [], [], 0];
    }
    const [byAreas, byContexts, byLayers, byOrgs, byProjects] = this.parseListByNamespace(fm);
    const minPriority = Helper.getField(fm.min_priority, 0);
    return [byAreas, byContexts, byLayers, byOrgs, byProjects, minPriority];
  }
  parseDoneList() {
    const fm = this.getCurrentFrontmatter();
    if (fm === void 0) {
      return [[], [], [], [], [], [], []];
    }
    const [byAreas, byContexts, byLayers, byOrgs, byProjects] = this.parseListByNamespace(fm);
    const [before, after] = this.parseListBeforeAfter(fm);
    const fields = Helper.getField(fm.fields, []);
    const stats = Helper.getField(fm.stats, []);
    return [
      byAreas,
      byContexts,
      byLayers,
      byOrgs,
      byProjects,
      fields,
      stats,
      before,
      after
    ];
  }
};
var NoteHelper = class {
  constructor(gonext, dv, frontmatter) {
    this.gonext = gonext;
    this.dv = dv;
    this.frontmatter = frontmatter;
  }
  isDoable(task) {
    const fm = task.file.frontmatter;
    if (fm.status !== Status.Todo) {
      return false;
    }
    if (fm.after !== void 0) {
      const after = new Date(fm.after);
      if (Date.now() <= after.getTime()) {
        return false;
      }
    }
    const deps = fm.needs;
    if (deps === void 0 || deps.length === 0) {
      return true;
    }
    if (this.hasPendingDependencies(deps)) {
      return false;
    }
    return true;
  }
  hasPendingDependencies(deps) {
    for (const dep of deps) {
      const task = this.dv.pages(`"${Paths.Tasks}/${dep}"`).array();
      if (task.length === 0) {
        console.warn(
          `hasPendingDependencies: "${Paths.Tasks}/${dep}" task does not exists`
        );
        continue;
      }
      const fm = task[0].file.frontmatter;
      if (fm.type !== Types.Task && fm.type !== Types.Provision && fm.type !== Types.Praxis) {
        continue;
      }
      if (fm.status === Status.Todo) {
        return true;
      }
    }
    return false;
  }
  isChildTag(parent, child) {
    if (child.length <= parent.length + 1) {
      return false;
    } else if (child.slice(0, parent.length + 1) != `${parent}/`) {
      return false;
    }
    return true;
  }
  getNamespaceContent(ns) {
    const children = [];
    const pages = this.dv.pages(`#${ns}`);
    for (const p of pages) {
      const tags = p.file.frontmatter.tags;
      if (tags === void 0 || tags.length === 0) {
        continue;
      }
      for (const tag of tags) {
        if (this.isChildTag(ns, tag)) {
          const t = tag.slice(ns.length + 1);
          if (!children.contains(t)) {
            children.push(t);
          }
        }
      }
    }
    return children;
  }
  isLastRevision(page) {
    const revisionList = (dv, root, current) => {
      let head = current;
      while (true) {
        const pages = dv.pages(`"${root}"`).where(
          (page2) => page2.file.frontmatter.next === head.file.frontmatter.uuid
        );
        if (pages.length > 1) {
          throw new Error();
        } else if (pages.length === 0) {
          break;
        }
        head = pages[0];
      }
      const buff = [];
      let cur = head;
      while (true) {
        buff.push(cur);
        const fm2 = cur.file.frontmatter;
        if (fm2.next === void 0) {
          break;
        }
        const pages = dv.pages(`"${root}/${fm2.next}"`);
        if (pages.length === 0) {
          break;
        }
        cur = pages[0];
      }
      return buff;
    };
    const note = page;
    const fm = note.file.frontmatter;
    let revisions = [];
    switch (fm.type) {
      case Types.Permanent:
        revisions = revisionList(this.dv, Paths.Slipbox, note);
        break;
      case Types.Resource:
        revisions = revisionList(this.dv, Paths.Resources, note);
        break;
      default:
        throw new Error();
    }
    if (revisions.length <= 1) {
      return true;
    }
    return revisions[0].file.frontmatter.uuid === fm.uuid;
  }
};
var ListMaker = class {
  constructor(gonext, dv, frontmatter) {
    this.gonext = gonext;
    this.dv = dv;
    this.frontmatter = frontmatter;
    this.noteHelper = new NoteHelper(gonext, dv, frontmatter);
  }
  nameInNamespace(fm, ns) {
    let found = false;
    if (ns.length === 0) {
      return true;
    }
    for (const a of ns) {
      const root = a.split("/");
      Assert.True(root.length === 2, `Invalid tag: '${a}'`);
      const parent = root[0].slice(0, 1) === "!" ? root[0].slice(1) : root[0];
      const name = Helper.getTag(fm, parent);
      if (a.slice(0, 1) === "!") {
        if (name === a.slice(1)) {
          return false;
        } else {
          found = true;
        }
      } else {
        if (name === a) {
          found = true;
        } else {
          found = false;
        }
      }
    }
    return found;
  }
  myNameInNamespace(name, ns) {
    let found = false;
    if (ns.length === 0) {
      return true;
    }
    for (const a of ns) {
      if (a.slice(0, 1) === "!") {
        if (name === a.slice(1)) {
          return false;
        } else {
          found = true;
        }
      } else {
        if (name === a) {
          found = true;
        } else {
          found = false;
        }
      }
    }
    return found;
  }
  filterByNamespace(fm, byAreas, byContexts, byLayers, byOrgs, byProjects) {
    if (!this.myNameInNamespace(Helper.getArea(fm), byAreas)) {
      return false;
    }
    if (!this.myNameInNamespace(Helper.getContext(fm), byContexts)) {
      return false;
    }
    if (!this.myNameInNamespace(Helper.getLayer(fm), byLayers)) {
      return false;
    }
    if (!this.myNameInNamespace(Helper.getOrg(fm), byOrgs)) {
      return false;
    }
    if (!this.myNameInNamespace(Helper.getProject(fm), byProjects)) {
      return false;
    }
    return true;
  }
  filterByDate(dt, before, after) {
    if (before !== void 0 && dt.getTime() > before.getTime()) {
      return false;
    }
    if (after !== void 0 && dt.getTime() < after.getTime()) {
      return false;
    }
    return true;
  }
  projectResourceSheet() {
    const curFm = this.frontmatter.getCurrentFrontmatter();
    if (curFm === void 0) {
      return;
    }
    const components = curFm.components;
    const domains = curFm.domains;
    let noteTypes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    if (!Helper.nilCheck(curFm.types) && curFm.types !== "*") {
      noteTypes = curFm.types;
    }
    const dropTasks = curFm.drop_status;
    const minMatchingComponent = components.length;
    const rs = {
      fleeting: [],
      literature: [],
      permanent: [],
      task: [],
      praxis: [],
      supply: [],
      log: [],
      resource: [],
      media: []
    };
    const Types2 = {
      0: "fleeting",
      1: "literature",
      2: "permanent",
      3: "task",
      4: "praxis",
      5: "supply",
      6: "log",
      7: "resource",
      8: "media"
    };
    const pages = this.dv.pages();
    for (const page of pages) {
      const fm = page.file.frontmatter;
      const tags = fm.tags;
      if (tags === void 0 || tags.length === 0) {
        continue;
      }
      const comp = [];
      for (const t of tags) {
        if (t.length > 10 && t.slice(0, 10) === "component/") {
          comp.push(t);
        }
      }
      if (comp.length < components.length) {
        continue;
      }
      let missing = 0;
      for (const component of components) {
        if (!comp.contains(component)) {
          missing += 1;
        }
      }
      if (components.length - missing < minMatchingComponent) {
        continue;
      }
      if (domains.length > 0) {
        let domain = "";
        for (const t of tags) {
          if (t.length > 7 && t.slice(0, 7) === "domain/") {
            domain = t;
            break;
          }
        }
        if (domain === "") {
          console.warn(
            `Missing domain for note: '${page.file.path}'`
          );
        }
        let found2 = false;
        for (const d of domains) {
          if (d === domain) {
            found2 = true;
          }
        }
        if (!found2) {
          continue;
        }
      }
      if (Types2[fm.type] === void 0) {
        console.warn(`Invalid type for note: '${page.file.path}'`);
        continue;
      }
      if (fm.type === 3 || fm.type === 4 || fm.type === 5) {
        let found2 = false;
        for (const status of dropTasks) {
          if (fm.status === status) {
            found2 = true;
            break;
          }
        }
        if (found2) {
          continue;
        }
      }
      let found = false;
      for (const t of noteTypes) {
        if (fm.type === t) {
          found = true;
          break;
        }
      }
      if (!found) {
        continue;
      }
      rs[Types2[fm.type]].push(page);
    }
    const resources = [];
    const types = Object.keys(rs);
    types.sort();
    for (const t of types) {
      if (rs[t].length === 0) {
        continue;
      }
      resources.push(["header", 2, t]);
      for (const note of rs[t]) {
        resources.push(["paragraph", this.dv.fileLink(note.file.path)]);
      }
    }
    return resources;
  }
  resourceLocatorGlobal() {
    const curFm = this.frontmatter.getCurrentFrontmatter();
    if (curFm === void 0) {
      return;
    }
    const components = [];
    if (Array.isArray(curFm.components)) {
      for (const component of curFm.components) {
        if (component.length > 10 && component.slice(0, 10) === "component/") {
          components.push(component);
        } else {
          components.push(`component/${component}`);
        }
      }
    }
    const domains = [];
    if (Array.isArray(curFm.domains)) {
      for (const domain of curFm.domains) {
        if (domain.length > 7 && domain.slice(0, 7) === "domain/") {
          domains.push(domain);
        } else {
          domains.push(`domain/${domain}`);
        }
      }
    }
    let minMatchingComponent = 0;
    if (components.length > 0) {
      if (Helper.nilCheck(curFm.min_matching_components)) {
        minMatchingComponent = components.length;
      } else {
        minMatchingComponent = curFm.min_matching_components;
      }
    }
    let noteTypes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
    if (!Helper.nilCheck(curFm.types) && curFm.types !== "*") {
      noteTypes = curFm.types;
    }
    const dropTasks = Helper.nilCheck(curFm.drop_status) ? [] : curFm.drop_status;
    const groupBy = "type";
    const rs = {
      fleeting: [],
      literature: [],
      permanent: [],
      task: [],
      praxis: [],
      supply: [],
      log: [],
      resource: [],
      media: [],
      org: [],
      domain: [],
      component: [],
      project: []
    };
    const Types2 = {
      1: "literature",
      2: "permanent",
      3: "task",
      4: "praxis",
      5: "supply",
      6: "log",
      7: "resource",
      8: "media",
      9: "org",
      10: "domain",
      11: "component",
      12: "project",
      13: "fleeting"
    };
    const pages = this.dv.pages().where((page) => {
      if (page.file.frontmatter.type !== void 0 && noteTypes.contains(page.file.frontmatter.type)) {
        return true;
      }
      return false;
    });
    for (const page of pages) {
      const fm = page.file.frontmatter;
      const tags = fm.tags;
      if (tags === void 0 || tags.length === 0) {
        continue;
      }
      const comp = [];
      for (const t of tags) {
        if (t.length > 10 && t.slice(0, 10) === "component/") {
          comp.push(t);
        }
      }
      let missing = 0;
      for (const component of components) {
        if (!comp.contains(component)) {
          missing += 1;
        }
      }
      if (components.length - missing < minMatchingComponent) {
        continue;
      }
      if (domains.length > 0) {
        let domain = "";
        for (const t of tags) {
          if (t.length > 7 && t.slice(0, 7) === "domain/") {
            domain = t;
            break;
          }
        }
        if (domain === "") {
          console.warn(
            `Missing domain for note: '${page.file.path}'`
          );
        }
        let found2 = false;
        for (const d of domains) {
          if (d === domain) {
            found2 = true;
          }
        }
        if (!found2) {
          continue;
        }
      }
      if (Types2[fm.type] === void 0) {
        console.warn(`Invalid type for note: '${page.file.path}'`);
        continue;
      }
      if (fm.type === 3 || fm.type === 4 || fm.type === 5 || fm.type === 8) {
        let found2 = false;
        for (const status of dropTasks) {
          if (fm.status === status) {
            found2 = true;
            break;
          }
        }
        if (found2) {
          continue;
        }
      }
      let found = false;
      for (const t of noteTypes) {
        if (fm.type === t) {
          found = true;
          break;
        }
      }
      if (!found) {
        continue;
      }
      if (fm.type === 7 || fm.type === 2) {
        if (!this.noteHelper.isLastRevision(page)) {
          continue;
        }
      }
      rs[Types2[fm.type]].push(page);
    }
    const buff = [];
    const types = Object.keys(rs);
    types.sort();
    for (const t of types) {
      if (rs[t].length === 0) {
        continue;
      }
      rs[t].sort((a, b) => {
        const createdAtA = this.frontmatter.getCreatedAt(a.file);
        const createdAtB = this.frontmatter.getCreatedAt(b.file);
        return createdAtA.getTime() - createdAtB.getTime();
      });
      buff.push(["header", 2, t]);
      buff.push(["array", Renderer.resourceBase, rs[t]]);
    }
    return buff;
  }
  indexAreaDomainMap() {
    const domainMap = {};
    const areaMap = {};
    for (const n of this.dv.pages(`"700 Link/Domains"`).array()) {
      const fm = n.file.frontmatter;
      if (fm.name === void 0 || fm.name === null || fm.name === "") {
        throw new Error(`Missing field 'name' for: ${n.file.path}`);
      }
      if (fm.areas === void 0 || fm.areas === void 0 || fm.areas.length === 0) {
        throw new Error(`Invalid area note: ${n.file.path}`);
      }
      const domain = `domain/${fm.name}`;
      if (domainMap[domain] === void 0) {
        domainMap[domain] = [];
      }
      for (const area of fm.areas) {
        if (!domainMap[domain].contains(area)) {
          domainMap[domain].push(area);
        }
        if (areaMap[area] === void 0) {
          areaMap[area] = [domain];
        } else {
          areaMap[area].push(domain);
        }
      }
    }
    return [domainMap, areaMap];
  }
  indexCommon(path) {
    const bins = {};
    const [domainMap, areaMap] = this.indexAreaDomainMap();
    const notes = this.dv.pages(`"${path}"`).array();
    const rs = [];
    for (const n of notes) {
      const fm = n.file.frontmatter;
      if (fm.tags === void 0 || fm.tags.length === 0) {
        continue;
      }
      const domain = Helper.getDomain(fm);
      if (domain === "domain/none") {
        throw new Error(`Invalid Node: ${n.file.path}`);
      }
      const components = [];
      for (const t of fm.tags) {
        if (t.length > 10 && t.slice(0, 10) === "component/") {
          components.push(t);
        }
      }
      if (components.length === 0) {
        components.push("component/unknown");
      }
      const areas2 = domainMap[domain];
      if (areas2 === void 0) {
        throw new Error(
          `Programming error 'areas' is undefined for domain: '${domain}' note: '${n.file.path}'`
        );
      }
      for (const a of areas2) {
        if (bins[a] === void 0) {
          bins[a] = {};
        }
        for (const d of areaMap[a]) {
          if (bins[a][d] === void 0) {
            bins[a][d] = {};
          }
          if (d !== domain) {
            continue;
          }
          for (const c of components) {
            if (bins[a][d][c] === void 0) {
              bins[a][d][c] = [n];
            } else {
              bins[a][d][c].push(n);
            }
          }
        }
      }
    }
    const areas = Object.keys(bins);
    areas.sort();
    rs.push(["header", 1, "Content"]);
    for (const a of areas) {
      rs.push(["header", 2, a.slice(5)]);
      rs.push(["paragraph", `#${a}`]);
      for (const d of areaMap[a]) {
        rs.push(["header", 3, d.slice(7)]);
        rs.push(["paragraph", `#${d}`]);
        const components = Object.keys(bins[a][d]);
        components.sort();
        for (const c of components) {
          rs.push(["header", 4, c.slice(10)]);
          rs.push(["paragraph", `#${c}`]);
          const tasks = bins[a][d][c];
          for (const t of tasks) {
            rs.push(["paragraph", this.dv.fileLink(t.file.path)]);
          }
        }
      }
    }
    return rs;
  }
  indexResources() {
    return this.indexCommon(Paths.Resources);
  }
  indexContent() {
    return this.indexCommon(Paths.Refs);
  }
  indexKnowledge() {
    const curFm = this.frontmatter.getCurrentFrontmatter();
    if (curFm === void 0) {
      return;
    }
    const allComponents = [];
    if (Array.isArray(curFm.components)) {
      for (const component of curFm.components) {
        if (component.length > 10 && component.slice(0, 10) === "component/") {
          allComponents.push(component);
        } else {
          allComponents.push(`component/${component}`);
        }
      }
    }
    const allDomains = [];
    if (Array.isArray(curFm.domains)) {
      for (const domain of curFm.domains) {
        if (domain.length > 7 && domain.slice(0, 7) === "domain/") {
          allDomains.push(domain);
        } else {
          allDomains.push(`domain/${domain}`);
        }
      }
    }
    const bins = {};
    let groupBy = "domain";
    if (!Helper.nilCheck(curFm.group_by)) {
      groupBy = curFm.group_by;
    }
    const [domainMap, areaMap] = this.indexAreaDomainMap();
    const notes = this.dv.pages(`"${Paths.Slipbox}"`).array();
    const rs = [];
    for (const n of notes) {
      const fm = n.file.frontmatter;
      if (fm.tags === void 0 || fm.tags.length === 0) {
        continue;
      }
      const domain = Helper.getDomain(fm);
      if (domain === "domain/none") {
        throw new Error(`Invalid Node: ${n.file.path}`);
      }
      if (!allDomains.contains(domain)) {
        continue;
      }
      const components = [];
      let isContent = false;
      for (const t of fm.tags) {
        if (t.length > 8 && t.slice(0, 8) === "content/") {
          isContent = true;
          break;
        }
        if (t.length > 10 && t.slice(0, 10) === "component/") {
          components.push(t);
        }
      }
      if (isContent) {
        continue;
      }
      if (components.length === 0) {
        components.push("component/unknown");
      }
      if (bins[domain] === void 0) {
        bins[domain] = {};
      }
      for (const c of components) {
        if (bins[domain][c] === void 0) {
          bins[domain][c] = [];
        }
        bins[domain][c].push(n);
      }
    }
    rs.push(["header", 1, "Index"]);
    if (groupBy === "domain") {
      const domains = Object.keys(bins);
      domains.sort();
      for (const domain of domains) {
        if (domainMap[domain] === void 0) {
          rs.push(["header", 2, "Error"]);
          rs.push(["paragraph", `domain: ${domain} is not in map`]);
          rs.push(["paragraph", `#${domain}`]);
          break;
        }
        if (allDomains.length > 0 && !allDomains.contains(domain)) {
          continue;
        }
        rs.push(["header", 2, domain.slice(7)]);
        rs.push(["paragraph", `#${domain}`]);
        const componentsNamespace = Object.keys(bins[domain]);
        componentsNamespace.sort();
        const components = {};
        for (const componentNamespace of componentsNamespace) {
          let fragment = "";
          const s = componentNamespace.split("/");
          const component = s[1];
          if (s.length === 3) {
            fragment = s[2];
          }
          if (components[component] === void 0) {
            components[component] = [fragment];
          } else {
            components[component].push(fragment);
          }
        }
        const cmp = Object.keys(components);
        cmp.sort();
        for (const component of cmp) {
          const fragments = components[component];
          fragments.sort();
          if (allComponents.length > 0 && !allComponents.contains(`component/${component}`)) {
            continue;
          }
          rs.push(["header", 3, component]);
          rs.push(["paragraph", `#component/${component}`]);
          if (fragments.length > 1) {
            for (const fragment of fragments) {
              const key = `component/${component}${fragment === "" ? "" : "/" + fragment}`;
              rs.push(["paragraph", `#${key}`]);
              const tasks = bins[domain][key];
              if (tasks !== void 0) {
                rs.push([
                  "array",
                  Renderer.knowledgeFull,
                  tasks
                ]);
              }
            }
          } else {
            const key = `component/${component}`;
            const tasks = bins[domain][key];
            if (tasks !== void 0) {
              rs.push(["array", Renderer.knowledgeFull, tasks]);
            }
          }
        }
      }
    } else if (groupBy === "component") {
      const buff = {};
      for (const domain of Object.keys(bins)) {
        for (const componentNamespace of Object.keys(bins[domain])) {
          let fragment = "";
          const s = componentNamespace.split("/");
          const component = s[1];
          if (s.length === 3) {
            fragment = s[2];
          }
          if (buff[component] === void 0) {
            buff[component] = {};
          }
          if (buff[component][fragment] === void 0) {
            buff[component][fragment] = {};
          }
          if (buff[component][fragment][domain] === void 0) {
            buff[component][fragment][domain] = [
              ...bins[domain][componentNamespace]
            ];
          } else {
            for (const task of bins[domain][componentNamespace]) {
              buff[component][fragment][domain].push(task);
            }
          }
        }
      }
      const components = Object.keys(buff);
      components.sort();
      for (const component of components) {
        rs.push(["header", 2, component]);
        rs.push(["paragraph", `#component/${component}`]);
        const fragments = Object.keys(buff[component]);
        fragments.sort();
        for (const fragment of fragments) {
          if (fragment !== "") {
            rs.push([
              "paragraph",
              `#component/${component}/${fragment}`
            ]);
          }
          const domains = Object.keys(buff[component][fragment]);
          domains.sort();
          for (const domain of domains) {
            rs.push(["header", 3, domain.slice(7)]);
            rs.push(["paragraph", `#${domain}`]);
            const tasks = buff[component][fragment][domain];
            for (const task of tasks) {
              rs.push([
                "paragraph",
                this.dv.fileLink(task.file.path)
              ]);
            }
          }
        }
      }
    } else {
      const ontologyMap = {};
      const pages = {};
      const keys = Object.keys(bins);
      keys.sort();
      for (const domain of keys) {
        const keys2 = Object.keys(bins[domain]);
        keys2.sort();
        for (const component of keys2) {
          for (const task of bins[domain][component]) {
            if (task.file.frontmatter.uuid === void 0) {
              continue;
            } else if (pages[task.file.frontmatter.uuid] !== void 0) {
              continue;
            }
            pages[task.file.frontmatter.uuid] = task;
          }
        }
      }
      const keys3 = Object.keys(pages);
      keys3.sort();
      for (const uuid of keys3) {
        const page = pages[uuid];
        const fm = page.file.frontmatter;
        const domain = Helper.getDomain(fm);
        const components = [];
        for (const tag of fm.tags) {
          if (tag.length > 10 && tag.slice(0, 10) === "component/") {
            components.push(tag);
          }
        }
        let s = "";
        s += `${domain}
`;
        components.sort();
        for (const component of components) {
          s += `${component}
`;
        }
        const key = s;
        if (ontologyMap[key] === void 0) {
          ontologyMap[key] = [page];
        } else {
          ontologyMap[key].push(page);
        }
      }
      const keys4 = Object.keys(ontologyMap);
      keys4.sort((a, b) => ontologyMap[a].length - ontologyMap[b].length);
      for (const key of keys4.reverse()) {
        rs.push(["header", 2, key]);
        for (const page of ontologyMap[key]) {
          rs.push([
            "paragraph",
            Renderer.makeLinkShortUUID(this.dv, page.file)
          ]);
        }
      }
    }
    return rs;
  }
  getProjectTasks(project) {
    return this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = page.file.frontmatter;
      if (page.type !== Types.Task && page.type !== Types.Media) {
        return false;
      }
      if (Helper.getProject(fm) !== `${Namespace.Project}/${project === "adhoc" ? "none" : project}`) {
        return false;
      }
      if (fm.status === Status.Done) {
        return false;
      }
      return true;
    });
  }
  projectTasksSheetRelationFrontmatter(dv) {
    const current = dv.current();
    const fm = new FrontmatterJS(current);
    return {
      name: fm.getName(),
      uuid: fm.uuid
    };
  }
  contextTasksSheet(dv) {
    const minPriority = 0;
    const rs = [];
    const bins = {
      doable: [],
      waiting: [],
      journal: []
    };
    const pages = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = page.file.frontmatter;
      if (page.type !== Types.Task && page.type !== Types.Media) {
        return false;
      }
      if (fm.status === Status.Done) {
        return false;
      }
      const fmjs = new FrontmatterJS(page);
      if (fmjs.getContext() !== `outside`) {
        return false;
      }
      return true;
    });
    for (const task of pages) {
      const fm = task.file.frontmatter;
      if (fm.priority !== void 0 && fm.priority < minPriority) {
        continue;
      }
      if (this.noteHelper.isDoable(task)) {
        bins.doable.push(task);
      } else if (fm.status === Status.Todo) {
        bins.waiting.push(task);
      } else {
        continue;
      }
    }
    if (bins.doable.length > 0) {
      rs.push(["header", 2, `Next Actions (${bins.doable.length})`]);
      bins.doable.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.basicTaskJournal, bins.doable]);
    }
    if (bins.waiting.length > 0) {
      rs.push(["header", 2, `Waiting (${bins.waiting.length})`]);
      const buff = [];
      for (const task of bins.waiting) {
        const fm = task.file.frontmatter;
        fm.cause = "unknown";
        buff.push(task);
      }
      rs.push(["array", Renderer.waitingTask, buff]);
    }
    return rs;
  }
  projectTasksSheetRelation(dv) {
    const project = this.projectTasksSheetRelationFrontmatter(dv);
    const minPriority = 0;
    const rs = [];
    const bins = {
      nextAction: [],
      doable: [],
      waiting: [],
      journal: [],
      maybe: []
    };
    const tasks = this.getProjectTasks(project.name);
    for (const task of tasks) {
      const fm = task.file.frontmatter;
      if (fm.priority !== void 0 && fm.priority < minPriority) {
        continue;
      }
      if (this.noteHelper.isDoable(task)) {
        if (fm.priority == 9) {
          bins.nextAction.push(task);
        } else if (fm.priority > 0) {
          bins.doable.push(task);
        } else {
          bins.maybe.push(task);
        }
      } else if (fm.status === Status.Todo) {
        bins.waiting.push(task);
      } else if (fm.status === Status.Doing) {
      } else {
        throw new Error(`${fm.uuid}`);
      }
    }
    {
      let toReview = 0;
      const logs = this.getProjectLogs(dv, project);
      for (const log of logs) {
        if (log.file.frontmatter.reviewed < 1) {
          toReview += 1;
        }
      }
    }
    if (bins.nextAction.length > 0) {
      rs.push(["header", 2, `Next Actions (${bins.doable.length})`]);
      bins.nextAction.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.basicTaskJournal, bins.nextAction]);
    }
    if (bins.doable.length > 0) {
      rs.push(["header", 2, `Doable (${bins.doable.length})`]);
      bins.doable.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.basicTaskJournal, bins.doable]);
    }
    if (bins.waiting.length > 0) {
      rs.push(["header", 2, `Waiting (${bins.waiting.length})`]);
      const buff = [];
      for (const task of bins.waiting) {
        const fm = task.file.frontmatter;
        if (fm.needs !== void 0 && fm.needs.length > 0) {
          fm.cause = fm.needs;
        } else if (fm.after !== void 0) {
          fm.cause = `after: ${fm.after}`;
        } else {
          fm.cause = "unknown";
        }
        buff.push(task);
      }
      rs.push(["array", Renderer.waitingTask, buff]);
    }
    if (bins.maybe.length > 0) {
      rs.push(["header", 2, `Maybe`]);
      bins.maybe.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.readyTask, bins.maybe]);
    }
    const pages = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = page.file.frontmatter;
      if (page.type !== Types.Praxis) {
        return false;
      }
      if (Helper.getProject(fm) !== `${Namespace.Project}/${project.name === "adhoc" ? "none" : project.name}`) {
        return false;
      }
      if (fm.status === Status.Done) {
        return false;
      }
      return true;
    }).array();
    if (pages.length > 0) {
      rs.push(["header", 3, "Praxis"]);
      rs.push(["array", Renderer.praxisBase, pages]);
    }
    return rs;
  }
  projectLogsSheetRelation(dv) {
    const project = this.projectTasksSheetRelationFrontmatter(dv);
    const filterBy = [];
    const rs = [];
    rs.push(["header", 2, "Logs"]);
    const logs = this.dv.pages(`"${Paths.Logs}"`).where((page) => {
      if (page.type !== Types.Log) {
        return false;
      }
      if (page.file.frontmatter.reviewed > 0) {
        return false;
      }
      return true;
    });
    const buff = {};
    for (const e of logs) {
      const fm = e.file.frontmatter;
      if (filterBy.length > 0 && !this.nameInNamespace(fm, filterBy)) {
        continue;
      }
      fm.createdAt = this.frontmatter.getCreatedAt(e.file);
      Assert.True(
        !Helper.nilCheck(fm.parent_id),
        `Missing field "parent_id" from log: "${fm.uuid}"`
      );
      const parent = this.dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
      if (parent.length !== 1) {
        continue;
      }
      Assert.True(
        parent.length === 1,
        `Parent: ${fm.parent_id} not found for log: "${fm.uuid}"`
      );
      fm.project = Helper.getProject(parent[0].file.frontmatter);
      fm.area = Helper.getArea(parent[0].file.frontmatter, true);
      if (fm.project !== `project/${project.name === "adhoc" ? "none" : project.name}`) {
        continue;
      }
      if (Helper.nilCheck(fm.done_at)) {
        continue;
      }
      const date = fm.done_at.slice(0, 10);
      if (buff[date] === void 0) {
        buff[date] = [e];
      } else {
        buff[date].push(e);
      }
    }
    const keys = Object.keys(buff);
    keys.sort();
    for (const date of keys) {
      buff[date].sort(
        (a, b) => b.file.frontmatter.createdAt.getTime() - a.file.frontmatter.createdAt.getTime()
      );
    }
    for (const date of keys.reverse()) {
      rs.push(["header", 3, date]);
      rs.push(["array", Renderer.projectLogs, buff[date]]);
    }
    return rs;
  }
  projectTasksSheet(dv) {
    const project = this.frontmatter.projectParseMeta(dv);
    const fml = this.frontmatter.getCurrentFrontmatter();
    if (fml === void 0) {
      throw new Error(`Invalid frontmatter, cannot proceed`);
    }
    const minPriority = fml.min_priority === void 0 ? 0 : fml.min_priority;
    const journal = this.dv.pages(`"${Paths.Journal}"`).array()[0].file.frontmatter.tasks;
    const rs = [];
    rs.push(["header", 1, project.name]);
    const bins = {
      doable: [],
      waiting: [],
      journal: [],
      maybe: [],
      praxis: []
    };
    const tasks = this.getProjectTasks(project.name);
    for (const task of tasks) {
      const fm = task.file.frontmatter;
      if (fm.priority !== void 0 && fm.priority < minPriority) {
        continue;
      }
      if (this.noteHelper.isDoable(task)) {
        bins.doable.push(task);
      } else if (fm.status === Status.Todo) {
        bins.waiting.push(task);
      } else {
        bins.maybe.push(task);
      }
    }
    {
      let toReview = 0;
      const logs = this.getProjectLogs(dv, project);
      for (const log of logs) {
        if (log.file.frontmatter.reviewed < 1) {
          toReview += 1;
        }
      }
      rs.push(["header", 2, `Pending Logs (${toReview})`]);
      if (toReview > 0) {
        rs.push([
          "paragraph",
          `[[${Paths.Projects}/${project.name === "adhoc" ? "ad hoc" : project.name}/logs]]`
        ]);
      }
    }
    if (bins.doable.length > 0) {
      rs.push(["header", 2, `Next Actions (${bins.doable.length})`]);
      bins.doable.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.basicTaskJournal, bins.doable]);
    }
    if (bins.waiting.length > 0) {
      rs.push(["header", 2, `Waiting (${bins.waiting.length})`]);
      const buff = [];
      for (const task of bins.waiting) {
        const fm = task.file.frontmatter;
        if (fm.needs !== void 0 && fm.needs.length > 0) {
          fm.cause = fm.needs;
        } else if (fm.after !== void 0) {
          fm.cause = `after: ${fm.after}`;
        } else {
          fm.cause = "unknown";
        }
        buff.push(task);
      }
      rs.push(["array", Renderer.waitingTask, buff]);
    }
    if (bins.maybe.length > 0) {
      rs.push(["header", 2, `Maybe`]);
      bins.maybe.sort(
        (a, b) => (a.file.frontmatter.priority - b.file.frontmatter.priority) * -1
      );
      rs.push(["array", Renderer.readyTask, bins.maybe]);
    }
    const pages = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = page.file.frontmatter;
      if (page.type !== Types.Praxis) {
        return false;
      }
      if (Helper.getProject(fm) !== `${Namespace.Project}/${project.name === "adhoc" ? "none" : project.name}`) {
        return false;
      }
      if (fm.status === Status.Done) {
        return false;
      }
      return true;
    }).array();
    if (pages.length > 0) {
      rs.push(["header", 3, "Praxis"]);
      rs.push(["array", Renderer.praxisBase, pages]);
    }
    return rs;
  }
  getProjectLogs(dv, project) {
    const logs = this.dv.pages(`"${Paths.Logs}"`).where((page) => {
      if (page.type !== Types.Log) {
        return false;
      }
      return true;
    });
    const buff = [];
    for (const e of logs) {
      const fm = e.file.frontmatter;
      Assert.True(
        !Helper.nilCheck(fm.parent_id),
        `Missing field "parent_id" from log: "${fm.uuid}"`
      );
      const parent = this.dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
      if (parent.length !== 1) {
        continue;
      }
      fm.project = Helper.getProject(parent[0].file.frontmatter);
      fm.area = Helper.getArea(parent[0].file.frontmatter, true);
      if (fm.project !== `project/${project.name === "adhoc" ? "none" : project.name}`) {
        continue;
      }
      if (Helper.nilCheck(fm.done_at)) {
        continue;
      }
      buff.push(e);
    }
    return buff;
  }
  projectLogsSheet(dv) {
    const project = this.frontmatter.projectParseMeta(dv);
    const fml = this.frontmatter.getCurrentFrontmatter();
    if (fml === void 0) {
      throw new Error(`Invalid frontmatter, cannot proceed`);
    }
    const before = Helper.nilCheck(fml.before) ? new Date(0) : new Date(fml.before);
    const after = Helper.nilCheck(fml.after) ? new Date() : new Date(fml.after);
    const filterBy = this.frontmatter.parseListFilterBy(fml);
    const rs = [];
    let totalTime = 0;
    rs.push(["header", 1, project.name]);
    const logs = this.dv.pages(`"${Paths.Logs}"`).where((page) => {
      if (page.type !== Types.Log) {
        return false;
      }
      return true;
    });
    const buff = {};
    for (const e of logs) {
      const fm = e.file.frontmatter;
      if (filterBy.length > 0 && !this.nameInNamespace(fm, filterBy)) {
        continue;
      }
      fm.createdAt = this.frontmatter.getCreatedAt(e.file);
      Assert.True(
        !Helper.nilCheck(fm.parent_id),
        `Missing field "parent_id" from log: "${fm.uuid}"`
      );
      const parent = this.dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
      if (parent.length !== 1) {
        continue;
      }
      fm.project = Helper.getProject(parent[0].file.frontmatter);
      fm.area = Helper.getArea(parent[0].file.frontmatter, true);
      if (fm.project !== `project/${project.name === "adhoc" ? "none" : project.name}`) {
        continue;
      }
      if (Helper.nilCheck(fm.done_at)) {
        continue;
      }
      const date = fm.done_at.slice(0, 10);
      const createdAt = new Date(fm.created_at);
      const doneAt = new Date(fm.done_at);
      if (createdAt > before) {
        continue;
      }
      if (createdAt < after) {
        continue;
      }
      if (buff[date] === void 0) {
        buff[date] = [e];
      } else {
        buff[date].push(e);
      }
      const delta = doneAt.getTime() - createdAt.getTime();
      totalTime += delta;
    }
    dv.paragraph(
      `_totalTime (h):_ ${Math.round(totalTime / (1e3 * 60 * 60) * 10) / 10}`
    );
    const keys = Object.keys(buff);
    keys.sort();
    for (const date of keys) {
      buff[date].sort(
        (a, b) => b.file.frontmatter.createdAt.getTime() - a.file.frontmatter.createdAt.getTime()
      );
    }
    for (const date of keys.reverse()) {
      rs.push(["header", 3, date]);
      rs.push(["array", Renderer.projectLogs, buff[date]]);
    }
    return rs;
  }
  allTodoProjects() {
    const [byAreas, byContexts, byLayers, byOrgs, byProjects, minPriority] = this.frontmatter.parseTodoList();
    const fml = this.frontmatter.getCurrentFrontmatter();
    if (fml === void 0) {
      throw new Error(`Invalid frontmatter, cannot proceed`);
    }
    const filterBy = fml.filter_by;
    let groupBy = fml.group_by;
    if (typeof groupBy === "undefined" || groupBy === "") {
      groupBy = "";
    } else if (typeof groupBy === "string") {
    } else {
      throw new Error(`Unsuported implementation groupBy: '${groupBy}'`);
    }
    const today = this.dv.pages(`"${Paths.Journal}"`)[0].file.frontmatter.tasks;
    const projects = this.noteHelper.getNamespaceContent(Namespace.Project);
    projects.sort();
    const rs = [];
    rs.push(["header", 1, "Projects"]);
    for (const project of projects) {
      const bins = [];
      if (project === "none") {
        continue;
      }
      const tasks = this.dv.pages(`#${Namespace.Project}/${project}`).where(
        (page) => page.type === Types.Task && page.status === Status.Todo
      );
      let elCount = 0;
      for (const task of tasks) {
        const fm = task.file.frontmatter;
        if (filterBy !== void 0 && filterBy !== null && filterBy.length > 0) {
          if (!this.nameInNamespace(fm, filterBy)) {
            continue;
          }
        }
        if (today.contains(fm.uuid)) {
          continue;
        }
        if (fm.priority !== void 0 && fm.priority < minPriority) {
          continue;
        }
        if (this.noteHelper.isDoable(task)) {
          let by = groupBy;
          if (groupBy !== "") {
            by = Helper.getTag(
              task.file.frontmatter,
              groupBy,
              true
            );
            if (by === void 0) {
              by = "";
            }
          }
          if (bins[by] === void 0) {
            bins[by] = [task];
          } else {
            bins[by].push(task);
          }
          elCount++;
        }
      }
      if (elCount === 0) {
        continue;
      }
      rs.push(["header", 2, project]);
      if (groupBy === "") {
        bins[""].sort(
          (a, b) => a.file.frontmatter.priority - b.file.frontmatter.priority
        );
        rs.push(["array", Renderer.readyTask, bins[""]]);
      } else {
        const keys = Object.keys(bins);
        keys.sort();
        for (const key of keys) {
          if (key !== Helper.getTag({ tags: [] }, groupBy)) {
            rs.push(["header", 3, key]);
          }
          bins[key].sort(
            (a, b) => a.file.frontmatter.priority - b.file.frontmatter.priority
          );
          rs.push(["array", Renderer.readyTask, bins[key]]);
        }
      }
    }
    return rs;
  }
  logs() {
    const [groupBy, filterBy, before, after] = this.frontmatter.parseAllProgressedTasks();
    const tasks = this.dv.pages(`"${Paths.Tasks}"`).where((page) => page.file.frontmatter.status !== "doing");
    const buff = [];
    for (const task of tasks) {
      const fm = task.file.frontmatter;
      if (filterBy.length > 0 && !this.nameInNamespace(fm, filterBy)) {
        continue;
      }
      const timeEstimate = Helper.durationStringToSec(fm.time_estimate);
      if (timeEstimate === void 0 && fm.time_estimate !== void 0) {
        throw new Error(
          `Invalid value: "${fm.time_estimate}" for entry: "${fm.uuid}"`
        );
      } else {
        fm.timeEstimate = timeEstimate;
      }
      const logs = this.dv.pages(`"${Paths.Logs}/${fm.uuid}"`).where((page) => page.type === Types.Log).sort((k) => k.created_at, "asc");
      if (logs.length < 1) {
        continue;
      }
      fm.took = 0;
      const project = Helper.getField(Helper.getProject(fm, true), "");
      const area = Helper.getField(Helper.getArea(fm, true), "");
      for (const log of logs) {
        const fml = log.file.frontmatter;
        const entry = {
          alias: fm.alias,
          uuid: fm.uuid,
          logId: fml.uuid,
          estimate: fm.timeEstimate,
          project,
          area,
          domain: Helper.getField(Helper.getDomain(fm, true), ""),
          path: task.file.path,
          logPath: log.file.path,
          createdAt: void 0,
          doneAt: void 0,
          took: void 0,
          tookAcc: void 0,
          deltaAcc: void 0
        };
        if (fml.created_at === void 0) {
          console.log(log);
          throw new Error(
            `task: ${fm.uuid} last entry is missing 'created_at' field`
          );
        }
        if (fml.done_at === void 0) {
          console.log(log);
          throw new Error(
            `task: ${fm.uuid} last entry is missing 'done_at' field`
          );
        }
        entry.createdAt = new Date(fml.created_at);
        entry.doneAt = new Date(fml.done_at);
        if (!this.filterByDate(entry.doneAt, before, after)) {
          continue;
        }
        const took = (entry.doneAt.getTime() - entry.createdAt.getTime()) / 1e3;
        fm.took += took;
        entry.took = took;
        entry.tookAcc = fm.took;
        entry.deltaAcc = timeEstimate - fm.took;
        buff.push(entry);
      }
    }
    const keyGetter = Helper.getKey(groupBy);
    const bins = {};
    for (const entry of buff) {
      let d = void 0;
      try {
        d = keyGetter(entry);
      } catch (e) {
        throw new Error(entry);
      }
      if (bins[d] === void 0) {
        bins[d] = [entry];
      } else {
        bins[d].push(entry);
      }
    }
    const keys = Object.keys(bins);
    keys.sort();
    const rs = [];
    for (const key of keys.reverse()) {
      rs.push(["header", 2, key]);
      const arr = [];
      let totalTime = 0;
      for (const e of bins[key]) {
        const buff2 = [];
        buff2.push(
          Renderer.makeLinkShortUUID(
            this.dv,
            { path: e.path, frontmatter: { uuid: e.uuid } },
            "Task"
          )
        );
        buff2.push(
          Renderer.makeLinkShortUUID(
            this.dv,
            { path: e.logPath, frontmatter: { uuid: e.logId } },
            "Content"
          )
        );
        const convertSecondsToHours = (t) => {
          return Math.round(t / 3600 * 10) / 10;
        };
        buff2.push(`${convertSecondsToHours(e.took)}`);
        buff2.push(`${e.project}`);
        arr.push(buff2);
        totalTime += e.took;
      }
      totalTime = Math.round(totalTime / 3600 * 10) / 10;
      rs.push(["stats", "totalTime", "h", totalTime]);
      rs.push(["array", Renderer.basicProgressedTaskWithLog, arr]);
    }
    return rs;
  }
  inbox() {
    const rs = [];
    const buff = [];
    const filterBy = [];
    const minSize = 0;
    const maxSize = 4294967295;
    const fleetings = this.dv.pages(`"${Paths.Inbox}"`).array();
    for (const e of fleetings) {
      const fm = e.file.frontmatter;
      e.file.frontmatter.createdAt = this.frontmatter.getCreatedAt(
        e.file
      );
      const fmjs = new FrontmatterJS(e);
      fm.project = Helper.getProject(fm, true);
      fm.domain = `domain/${fmjs.getDomain()}`;
      fm.components = Helper.getComponents(fm);
      if (e.file.size < minSize) {
        continue;
      }
      if (e.file.size > maxSize) {
        continue;
      }
      buff.push(e);
    }
    const logs = this.dv.pages(`"${Paths.Logs}"`).where((p) => {
      if (p.type !== Types.Log) {
        return false;
      }
      const f = p.file;
      const createdAt = this.frontmatter.getCreatedAt(f);
      const now = new Date();
      if (createdAt.getTime() + 864e5 - now.getTime() > 0) {
        return false;
      }
      if (p.reviewed !== void 0 && p.reviewed >= 1) {
        return false;
      }
      const pages = this.dv.pages(`"${Paths.Tasks}/${f.frontmatter.parent_id}"`).array();
      if (pages.length !== 1) {
        return false;
      }
      return true;
    });
    for (const e of logs) {
      const fm = e.file.frontmatter;
      fm.createdAt = this.frontmatter.getCreatedAt(e.file);
      Assert.True(
        !Helper.nilCheck(fm.parent_id),
        `Missing field "parent_id" from log: "${fm.uuid}"`
      );
      const parent = this.dv.pages(`"${Paths.Tasks}/${fm.parent_id}"`).array();
      Assert.True(
        parent.length === 1,
        `Parent: ${fm.parent_id} not found for log: "${fm.uuid}"`
      );
      fm.project = Helper.getProject(parent[0].file.frontmatter, true);
      fm.domain = void 0;
      fm.components = [];
      if (e.file.size < minSize) {
        continue;
      }
      if (e.file.size > maxSize) {
        continue;
      }
      buff.push(e);
    }
    const sortBySizeThenDate = function(a, b) {
      const fA = a.file;
      const fB = b.file;
      if (fA.size !== fB.size) {
        return fB.size - fA.size;
      } else {
        return fA.frontmatter.createdAt.getTime() - fB.frontmatter.createdAt.getTime();
      }
    };
    const sortByAge = (a, b) => a.file.frontmatter.createdAt.getTime() - b.file.frontmatter.createdAt.getTime();
    buff.sort(sortByAge);
    const filterFunc = (page) => {
      const fm = page.file.frontmatter;
      return true;
      if (Helper.getProject(fm, true) !== void 0) {
        return false;
      }
      if (Helper.getDomain(fm, true) !== void 0) {
        return false;
      }
      return true;
    };
    rs.push(["array", Renderer.inboxEntry, buff.filter(filterFunc)]);
    return rs;
  }
  domains() {
    const pages = this.dv.pages(`"${Paths.Domains}"`).where((page) => {
      const fm = page.file.frontmatter;
      if (fm.name === void 0) {
        return false;
      }
      if (this.dv.pages(`#domain/${fm.name}`).array().length <= 0) {
        return false;
      }
      return true;
    }).sort((k) => k.name, "asc").array();
    const rs = [];
    const buff = [];
    for (const page of pages) {
      const fm = new FrontmatterJS(page);
      fm.resolve(this.dv);
      buff.push(fm);
    }
    rs.push(["array", Renderer.basicDomain, buff]);
    return rs;
  }
  components() {
    const pages = this.dv.pages(`"${Paths.Components}"`).sort((k) => k.name, "asc").array();
    const rs = [];
    const buff = [];
    for (const page of pages) {
      const fm = new FrontmatterJS(page);
      fm.resolve(this.dv);
      buff.push(fm);
    }
    rs.push(["array", Renderer.basicDomain, buff]);
    return rs;
  }
  names() {
    const pages = this.dv.pages(`"${Paths.Names}"`).sort((k) => k.name, "asc").array();
    const rs = [];
    const buff = [];
    for (const page of pages) {
      const fm = new FrontmatterJS(page);
      fm.resolve(this.dv);
      buff.push(fm);
    }
    rs.push(["array", Renderer.basicDomain, buff]);
    return rs;
  }
  projects() {
    let fml = this.frontmatter.getCurrentFrontmatter();
    if (fml === void 0) {
      fml = { inactive: [] };
    }
    const rs = [];
    const bins = {
      active: [],
      inactive: []
    };
    const pages = this.dv.pages(`"Projects"`).sort((k) => k.name, "asc");
    for (const project of pages) {
      const fmProject = new FrontmatterJS(project);
      if (fmProject.getName() === "adhoc") {
        bins.active.push(project);
        continue;
      }
      const tasks = this.dv.pages(`#project/${fmProject.getName()}`).where((page) => {
        if (page.file.folder !== `${Paths.Tasks}`) {
          return false;
        }
        const fmTask = new FrontmatterJS(page);
        if (fmTask.getProject() !== fmProject.getName()) {
          return false;
        }
        if (fmTask.fm.status === "todo" || fmTask.fm.status === "doing") {
          return true;
        }
        return false;
      });
      let nextActionCount = 0;
      for (const task of tasks) {
        if (task.file.frontmatter.priority === 9) {
          nextActionCount++;
        }
      }
      if (tasks.length === 0 || nextActionCount === 0 || fml.inactive.contains(fmProject.getName())) {
        bins.inactive.push(project);
      } else {
        bins.active.push(project);
      }
    }
    rs.push(["array", Renderer.basicRelation, bins.active]);
    rs.push(["header", 2, "Inactive"]);
    rs.push(["array", Renderer.basicRelation, bins.inactive]);
    return rs;
  }
  praxis() {
    const pages = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      if (page.file.frontmatter.type !== Types.Praxis) {
        return false;
      }
      if (page.file.frontmatter.status !== Status.Todo) {
        return false;
      }
      return true;
    }).array();
    const rs = [];
    rs.push(["header", 1, "Praxis"]);
    rs.push(["array", Renderer.basicTask, pages]);
    return rs;
  }
  goals() {
    const fm = this.frontmatter.getCurrentFrontmatter();
    const filterBy = new FilterBy(fm);
    const rs = [];
    const pages = this.dv.pages(`"${Paths.Goals}"`).where((page) => {
      const fmp = page.file.frontmatter;
      if (fmp.status !== "todo") {
        return false;
      }
      return true;
    });
    const buff = [];
    for (const page of pages) {
      const p = new FrontmatterJS(page);
      if (filterBy.filter(page.file.frontmatter)) {
        continue;
      }
      buff.push(p);
    }
    buff.sort((a, b) => {
      const dta = new Date(a.fm.before);
      const dtb = new Date(b.fm.before);
      return dta.getTime() - dtb.getTime();
    });
    rs.push(["header", 1, "Goals"]);
    rs.push(["array", Renderer.goal, buff]);
    return rs;
  }
  operations() {
    const fm = this.frontmatter.getCurrentFrontmatter();
    const filterBy = new FilterBy(fm);
    const rs = [];
    const pages = this.dv.pages(`"Operations"`).where((page) => {
      const fmp = page.file.frontmatter;
      return true;
    });
    const buff = [];
    for (const page of pages) {
      const p = new FrontmatterJS(page);
      if (filterBy.filter(page.file.frontmatter)) {
        continue;
      }
      buff.push(p);
    }
    buff.sort((a, b) => {
      const dta = new Date(a.fm.before);
      const dtb = new Date(b.fm.before);
      return dta.getTime() - dtb.getTime();
    });
    rs.push(["header", 1, "Operations"]);
    rs.push(["array", Renderer.readyTask, buff]);
    return rs;
  }
  journal() {
    const [byAreas, byContexts, byLayers, byOrgs, byProjects, fmTasks] = this.frontmatter.parseJournal();
    const fm = this.frontmatter.getCurrentFrontmatter();
    if (fmTasks < 1) {
      throw new Error("No tasks !");
    }
    const groupBy = void 0;
    const bins = {
      doable: [],
      waiting: [],
      done: [],
      active: [],
      leisure: [],
      media: []
    };
    const tasks = this.dv.pages(`"${Paths.Tasks}"`).where((k) => fmTasks.contains(k.uuid)).sort((k) => k.priority, "desc");
    if (tasks.length !== fmTasks.length) {
      {
        const taskss = [];
        for (const task of tasks) {
          taskss.push(task.file.frontmatter.uuid);
        }
        for (const task of fmTasks) {
          if (!taskss.contains(task)) {
            console.warn(task);
          }
        }
      }
      throw new Error("Refer to logs");
    }
    let totalEstimate = 0;
    for (const task of tasks) {
      const fmt = task.file.frontmatter;
      if (fmt.type === Types.Praxis) {
        const logs = this.dv.pages(`"${Paths.Logs}/${fmt.uuid}"`).sort((page) => page.file.frontmatter.created_at, "desc").array();
        if (logs.length > 0) {
          const lastEntry = logs[0];
          const createdAt = this.frontmatter.getCreatedAt(
            lastEntry.file
          );
          const now = new Date();
          if (now.toISOString().slice(0, 10) === createdAt.toISOString().slice(0, 10)) {
            bins.done.push(task);
            continue;
          }
        }
      }
      if (Helper.getDomain(fmt) === "domain/leisure") {
        bins.leisure.push(task);
        continue;
      }
      if (fmt.type === Types.Media) {
        bins.media.push(task);
        continue;
      }
      if (this.noteHelper.isDoable(task)) {
        const timeEstimate = fmt.time_estimate;
        if (timeEstimate !== void 0) {
          totalEstimate += Helper.durationStringToSec(timeEstimate);
        }
        bins.doable.push(task);
        continue;
      }
      if (fmt.status === Status.Done) {
        bins.done.push(task);
      } else if (fmt.status !== Status.Doing) {
        bins.waiting.push(task);
      }
    }
    const arr = [];
    arr.push(["header", 1, "Journal"]);
    arr.push(["header", 2, `${fm.tasks.length}/25 tasks`]);
    arr.push([
      "stats",
      "totalEstimate",
      "h",
      `${String(Math.round(totalEstimate / 3600 * 10) / 10).padStart(
        2,
        "0"
      )}`
    ]);
    const doing = this.dv.pages(`"${Paths.Tasks}"`).where((page) => page.file.frontmatter.status === Status.Doing).array();
    if (doing.length > 0) {
      arr.push(["header", 2, `Active (${doing.length})`]);
      arr.push(["array", Renderer.activeTask, doing]);
    }
    if (bins.doable.length > 0) {
      arr.push(["header", 2, `Doable (${bins.doable.length})`]);
      if (groupBy !== "" && groupBy !== void 0) {
        const res = {};
        for (const e of bins.doable) {
          const fm2 = e.file.frontmatter;
          let t = Helper.getTag(fm2, groupBy);
          if (groupBy === "context" && t === "context/any" && Helper.getOrg(fm2) !== "org/none") {
            t = "context/work";
          }
          if (res[t] === void 0) {
            res[t] = [e];
          } else {
            res[t].push(e);
          }
        }
        for (const k of Object.keys(res).sort()) {
          res[k].sort(
            (a, b) => Helper.getField(b.file.frontmatter.priority, 0) - Helper.getField(a.file.frontmatter.priority, 0)
          );
          arr.push(["header", 3, k]);
          arr.push(["array", Renderer.basicTask, res[k]]);
        }
      } else {
        bins.doable.sort(
          (a, b) => Helper.getField(b.file.frontmatter.priority, 0) - Helper.getField(a.file.frontmatter.priority, 0)
        );
        arr.push(["array", Renderer.basicTask, bins.doable]);
      }
    }
    if (bins.waiting.length > 0) {
      arr.push(["header", 2, `Waiting (${bins.waiting.length})`]);
      const buff = [];
      for (const task of bins.waiting) {
        const fm2 = task.file.frontmatter;
        if (fm2.needs !== void 0 && fm2.needs.length > 0) {
          fm2.cause = fm2.needs;
        } else if (fm2.after !== void 0) {
          fm2.cause = `after: ${fm2.after}`;
        } else {
          fm2.cause = "unknown";
        }
        buff.push(task);
      }
      arr.push(["array", Renderer.waitingTask, buff]);
    }
    if (bins.media.length > 0) {
      arr.push(["header", 2, `Media (${bins.media.length})`]);
      arr.push(["array", Renderer.mediaWithLogs, bins.media]);
    }
    if (bins.done.length > 0) {
      arr.push(["header", 2, `Done (${bins.done.length})`]);
      arr.push(["array", Renderer.basicTask, bins.done]);
    }
    if (bins.leisure.length > 0) {
      arr.push(["header", 2, `Leisure (${bins.leisure.length})`]);
      arr.push(["array", Renderer.mediaWithLogs, bins.leisure]);
    }
    const provisions = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      if (page.file.frontmatter.type === void 0) {
        return false;
      }
      if (page.file.frontmatter.type !== Types.Provision) {
        return false;
      }
      if (page.file.frontmatter.status === void 0) {
        return false;
      }
      if (page.file.frontmatter.status !== Status.Todo) {
        return false;
      }
      return true;
    }).array();
    if (provisions.length > 0) {
      arr.push(["header", 2, `Provision (${provisions.length})`]);
      arr.push(["array", Renderer.provisionBase, provisions]);
    }
    return arr;
  }
  library() {
    const rs = [];
    const domains = [];
    const refDomains = [];
    {
      const pages = this.dv.pages(`"${Paths.Domains}"`).sort((k) => k.name, "asc").array();
      for (const page of pages) {
        const fm = new FrontmatterJS(page);
        fm.resolve(this.dv);
        domains.push(fm.getName());
      }
    }
    {
      for (const domain of domains) {
        rs.push(["header", 2, `${domain}`]);
        const pages = this.dv.pages(`"802 Refs"`).where((page) => {
          const fm = new FrontmatterJS(page);
          const content = fm.getContent();
          if (content === "person" || content === "place") {
            return false;
          }
          if (!domains.contains(fm.getDomain(false))) {
            if (!refDomains.contains(fm.getDomain(false))) {
              refDomains.push(fm.getDomain(false));
            }
          }
          return fm.getDomain(false) === domain;
        });
        rs.push(["array", Renderer.knowledgeBase, pages]);
      }
      {
        if (refDomains.length === 0) {
          return rs;
        }
        rs.push(["header", 2, "undeclared domains"]);
        for (const domain of refDomains) {
          rs.push(["header", 3, domain]);
          const pages = this.dv.pages(`"802 Refs"`).where((page) => {
            const fm = new FrontmatterJS(page);
            const content = fm.getContent();
            if (content === "person" || content === "place") {
              return false;
            }
            return fm.getDomain(false) === domain;
          });
          rs.push(["array", Renderer.knowledgeBase, pages]);
        }
      }
    }
    return rs;
  }
  planning() {
    const rs = [];
    const pages = this.dv.pages(`"${Paths.Tasks}"`).where((page) => {
      const fm = new FrontmatterJS(page);
      if (fm.at === void 0) {
        return false;
      }
      if (fm.getProject() !== "daily") {
        return false;
      }
      return true;
    }).sort((page) => page.file.frontmatter.at, "desc");
    const bins = {};
    for (const page of pages) {
      const fm = new FrontmatterJS(page);
      let at = void 0;
      try {
        at = fm.at.toISOString().slice(0, 10);
      } catch (e) {
        throw new Error(`Invalid date: '${fm.fm.uuid}'`);
      }
      const weekNumber = this.getWeekNumber(fm.at);
      if (bins[weekNumber] === void 0) {
        bins[weekNumber] = [fm];
      } else {
        bins[weekNumber].push(fm);
      }
    }
    const now = new Date();
    const currentWeekNumber = this.getWeekNumber(now);
    for (const key of Object.keys(bins)) {
      const weekNumber = Number(key);
      if (weekNumber < currentWeekNumber) {
        rs.push(["header", 2, `~~week ${key}~~`]);
      } else if (weekNumber === currentWeekNumber) {
        rs.push(["header", 2, `*week ${key}*`]);
      } else {
        rs.push(["header", 2, `week ${key}`]);
      }
      bins[key].sort((a, b) => {
        return a.at.getTime() - b.at.getTime();
      });
      for (const task of bins[key]) {
        const day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][task.at.getDay()];
        const text = Renderer.makeLink(
          this.dv,
          task.f,
          `${task.at.toISOString().slice(0, 10)}, ${day}`,
          "daily"
        );
        if (weekNumber < currentWeekNumber) {
          rs.push(["paragraph", `~~${text}~~`]);
        } else if (weekNumber === currentWeekNumber) {
          if (this.dayOfYear(task.at) < this.dayOfYear(now)) {
            rs.push(["paragraph", `~~${text}~~`]);
          } else {
            rs.push(["paragraph", `${text}`]);
          }
        } else {
          rs.push(["paragraph", `${text}`]);
        }
      }
    }
    return rs;
  }
  dayOfYear(dt) {
    const year = dt.getFullYear();
    const month = dt.getMonth() + 1;
    const day = dt.getDate();
    const N1 = Math.floor(275 * month / 9);
    const N2 = Math.floor((month + 9) / 12);
    const N3 = 1 + Math.floor((year - 4 * Math.floor(year / 4) + 2) / 3);
    return N1 - N2 * N3 + day - 30;
  }
  getWeekNumber(d) {
    d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil(((d - yearStart) / 864e5 + 1) / 7);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var MyPlugin = class extends import_obsidian.Plugin {
  printCoucou() {
    console.log("Couou, tu veux voir ma bite?");
  }
  // reviewLog() {
  // 	const fm = this.getCurrentFrontmatter();
  // 	if (fm === undefined) {
  // 		return;
  // 	}
  //
  // 	if (fm.type === undefined) {
  // 		// console.warn(`file: ${fm} does not have a valid schema`);
  // 		return;
  // 	}
  //
  // 	if (fm.type !== 6) {
  // 		// console.warn(`file: ${fm} is not of "log" type`);
  // 		return;
  // 	}
  //
  // 	const currentReviewed = fm.reviewed;
  // 	// obsidian plugin API, write file on disk, frontmatter changed
  // }
  async onload() {
    var _a, _b;
    console.log("gonext - onload()");
    await this.loadSettings();
    this.metadataCache = app.metadataCache;
    this.workspace = app.workspace;
    this.dv = app.plugins.plugins.dataview.api;
    this.frontmatter = new Frontmatter(this);
    this.listMaker = new ListMaker(this, this.dv, this.frontmatter);
    this.api = {
      getArea: Helper.getArea,
      getContext: Helper.getContext,
      getDomain: Helper.getDomain,
      getLayer: Helper.getLayer,
      getOrg: Helper.getOrg,
      getProject: Helper.getProject,
      durationStringToSec: Helper.durationStringToSec,
      paths: Paths,
      types: Types,
      status: Status,
      namespace: Namespace,
      default: Default,
      frontmatter: this.frontmatter,
      listMaker: this.listMaker,
      renderer: Renderer,
      autoField: AutoField
    };
    window.gonext = {
      // @ts-ignore
      state: (_b = (_a = window.gonext) == null ? void 0 : _a.state) != null ? _b : {},
      // @ts-ignore
      app: this.app
    };
    this.taskInStatusBar = this.addStatusBarItem();
    this.taskInStatusBar.setText("");
    this.app.workspace.on("active-leaf-change", () => {
      const leaf = app.workspace.activeLeaf;
      const tabTitleOrig = leaf.tabHeaderInnerTitleEl.innerText;
      if (tabTitleOrig.length !== 36) {
        return;
      }
      const fm = this.frontmatter.getCurrentFrontmatter();
      if (fm === void 0) {
        return void 0;
      }
      const alias = fm.alias;
      if (Helper.nilCheck(alias) || alias === "") {
        return;
      }
      leaf.tabHeaderInnerTitleEl.innerText = alias;
      leaf.tabHeaderInnerTitleEl.innerHTML = alias;
    });
    this.addCommand({
      id: "gonext-utils-copy-current-file-uuid",
      name: "Copy current file UUID",
      // @ts-ignore
      editorCallback: (editor, view) => {
        const fm = this.gonext.getCurrentFrontmatter();
        if (fm === void 0) {
          return;
        }
        if (fm.uuid == void 0) {
          return;
        }
      }
    });
    this.addCommand({
      id: "safe-delete",
      name: "Safe Delete",
      // @ts-ignore
      editorCallback: (editor, view) => {
        const file = app.workspace.getActiveFile();
        const fm = app.metadataCache.getFileCache(file).frontmatter;
        if (fm === void 0) {
          return;
        }
        const rootPath = [
          `${Paths.Journal}.md`,
          `${Paths.Inbox}.md`,
          "Ad Hoc.md",
          "allDoneTasks.md",
          "allDoneTasksWithoutLog.md",
          "allMedia.md",
          "allProgressedTasks.md",
          "noteLocator.md",
          "Praxis.md"
        ];
        for (const p of rootPath) {
          if (file.path === p) {
            return;
          }
        }
        if (
          // @ts-ignore
          file.path.split(0, Paths.Resources.length) === // @ts-ignore
          Paths.Resources
        ) {
          return;
        }
        console.log(`deleted file: ${file.path}`);
        app.vault.delete(file);
      }
    });
    this.addCommand({
      id: "display-modal",
      name: "Display modal",
      callback: () => {
        new ExampleModal(this.app).open();
      }
    });
    this.addCommand({
      id: "go-parent",
      name: "Go Parent",
      // @ts-ignore
      editorCallback: (editor, view) => {
        const file = app.workspace.getActiveFile();
        const fm = app.metadataCache.getFileCache(file).frontmatter;
        if (fm === void 0) {
          return;
        }
        if (fm.parent_id === void 0 && fm.ref_id === void 0) {
          console.warn(
            `parent_id: '${fm.parent_id}' ref_id: '${fm.ref_id}'`
          );
          return;
        }
        if (fm.type === void 0 || fm.type !== Types.Log && fm.type !== Types.Media && fm.type !== Types.Fleeting) {
          console.warn(
            `invalid type: '${fm.type}' for note: '${fm.uuid}'`
          );
          return;
        }
        const parent = fm.type === Types.Log ? `${Paths.Tasks}/${fm.parent_id}.md` : `${Paths.Refs}/${fm.ref_id}.md`;
        const page = app.vault.getAbstractFileByPath(parent);
        app.workspace.openLinkText(parent, "/", false);
      }
    });
  }
  onunload() {
    console.log("gonext - onunload()");
    delete window.gonext;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ExampleModal = class extends import_obsidian.Modal {
  constructor(app2) {
    super(app2);
  }
  onOpen() {
    const { contentEl } = this;
    const dv = this.app.plugins.plugins.dataview.api;
    const tasks = dv.pages().array().slice(0, 10);
    let s = "";
    for (const task of tasks) {
      s += `${task.file.path}

`;
    }
    contentEl.setText(s);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
